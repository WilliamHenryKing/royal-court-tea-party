<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>The Royal Court Tea ‚ú®</title>
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    :root {
      --pink-light: #ffd1e1; --pink-main: #f5a1c0; --pink-deep: #e87aa0;
      --lavender: #d4b8ff; --periwinkle: #a9c7ff; --mint: #b8e986; --mint-dark: #9ed36a;
      --sky: #cfeeff; --peach: #ffd4a8; --cream: #fff8f0; --gold: #ffd700;
      --text-dark: #4a3f5c; --text-light: #7a6b8a; --white: #ffffff;
    }
    html, body { width: 100%; height: 100%; overflow: hidden; font-family: 'Inter', sans-serif; background: linear-gradient(180deg, #ffeef5 0%, #e8f4ff 100%); touch-action: none; }
    #game-container { width: 100%; height: 100%; position: relative; }
    canvas { display: block; touch-action: none; }

    #splash-screen {
      position: fixed; inset: 0; background: linear-gradient(135deg, #fff0f5 0%, #ffe4ec 30%, #ffd1e1 60%, #e8d4f0 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start; z-index: 1000;
      transition: opacity 0.8s ease, visibility 0.8s ease; overflow-y: auto; overflow-x: hidden;
      padding: 2rem 1rem;
    }
    #splash-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    .splash-sparkle { position: absolute; font-size: 1.5rem; opacity: 0.6; animation: floatSparkle 4s ease-in-out infinite; pointer-events: none; }
    @keyframes floatSparkle { 0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.6; } 50% { transform: translateY(-20px) rotate(180deg); opacity: 1; } }
    .splash-crown-container { position: relative; margin-bottom: 1rem; }
    .splash-crown { font-size: 5rem; animation: crownBounce 2s ease-in-out infinite; filter: drop-shadow(0 10px 30px rgba(255,215,0,0.4)); }
    .splash-glow { position: absolute; inset: -30px; background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, transparent 70%); animation: glowPulse 2s ease-in-out infinite; border-radius: 50%; }
    @keyframes crownBounce { 0%, 100% { transform: translateY(0) rotate(-3deg) scale(1); } 25% { transform: translateY(-15px) rotate(3deg) scale(1.05); } 50% { transform: translateY(-5px) rotate(-2deg) scale(1.02); } 75% { transform: translateY(-20px) rotate(2deg) scale(1.03); } }
    @keyframes glowPulse { 0%, 100% { opacity: 0.5; transform: scale(1); } 50% { opacity: 1; transform: scale(1.2); } }
    .splash-title { font-family: 'Dancing Script', cursive; font-size: 2.4rem; color: var(--text-dark); text-shadow: 2px 2px 0 var(--white), 4px 4px 10px rgba(0,0,0,0.1); margin-bottom: 0.3rem; animation: fadeSlideIn 1s ease 0.3s both; }
    .splash-subtitle { font-family: 'Dancing Script', cursive; font-size: 1.3rem; color: var(--pink-deep); margin-bottom: 0.3rem; animation: fadeSlideIn 1s ease 0.5s both; }
    .splash-tagline { font-size: 0.9rem; color: var(--text-light); font-style: italic; margin-bottom: 1rem; animation: fadeSlideIn 1s ease 0.7s both; }
    @keyframes fadeSlideIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    .splash-instruction { background: rgba(255,255,255,0.8); backdrop-filter: blur(10px); padding: 0.8rem 1.2rem; border-radius: 1rem; margin-bottom: 1rem; max-width: 300px; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.1); animation: fadeSlideIn 1s ease 0.9s both; }
    .splash-instruction p { color: var(--text-dark); line-height: 1.5; font-size: 0.9rem; }
    .splash-instruction strong { color: var(--pink-deep); }
    .splash-btn { background: linear-gradient(135deg, var(--pink-main) 0%, var(--lavender) 100%); border: none; padding: 1rem 2.5rem; border-radius: 3rem; color: var(--white); font-family: 'Inter', sans-serif; font-weight: 700; font-size: 1.1rem; cursor: pointer; box-shadow: 0 8px 30px rgba(245, 161, 192, 0.5); transition: all 0.3s ease; animation: fadeSlideIn 1s ease 1.2s both, btnPulse 2s ease-in-out infinite 2.2s; }
    .splash-btn:active { transform: scale(0.97); }
    @keyframes btnPulse { 0%, 100% { box-shadow: 0 8px 30px rgba(245, 161, 192, 0.5); } 50% { box-shadow: 0 8px 50px rgba(245, 161, 192, 0.8); } }
    .splash-footer { margin-top: 1rem; margin-bottom: 1rem; font-size: 0.75rem; color: var(--text-light); opacity: 0.7; animation: fadeSlideIn 1s ease 1.4s both; }
    
    .splash-map { 
      background: rgba(255,255,255,0.9); 
      backdrop-filter: blur(10px); 
      border-radius: 1.2rem; 
      padding: 0.6rem; 
      margin-bottom: 1rem; 
      max-width: 280px; 
      width: 90%; 
      box-shadow: 0 8px 32px rgba(0,0,0,0.1); 
      animation: fadeSlideIn 1s ease 0.95s both;
      border: 2px solid rgba(255,215,0,0.3);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .splash-map:hover { border-color: rgba(255,215,0,0.6); }
    .splash-map.zoomed {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 95vw;
      max-height: 85vh;
      width: 500px;
      z-index: 1005 !important;
      padding: 1.2rem;
      border: 3px solid var(--gold);
      box-shadow: 0 20px 60px rgba(0,0,0,0.4);
      animation: zoomIn 0.3s ease forwards;
      background: rgba(255,255,255,0.98);
    }
    @keyframes zoomIn { 
      from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 
      to { transform: translate(-50%, -50%) scale(1); opacity: 1; } 
    }
    .splash-map.zoomed .map-title { font-size: 1.5rem; margin-bottom: 0.5rem; }
    .splash-map.zoomed .map-legend { font-size: 0.9rem; margin-top: 0.6rem; }
    .map-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: transparent;
      z-index: 1001;
      animation: fadeIn 0.3s ease;
    }
    .map-overlay.visible { display: block; }
    .map-tap-hint {
      font-size: 0.65rem;
      color: var(--text-light);
      text-align: center;
      margin-top: 0.2rem;
      opacity: 0.8;
    }
    .splash-map.zoomed .map-tap-hint { display: none; }
    .map-close-hint {
      display: none;
      font-size: 0.8rem;
      color: var(--text-light);
      text-align: center;
      margin-top: 0.5rem;
    }
    .splash-map.zoomed .map-close-hint { display: block; }
    .map-title { 
      font-family: 'Dancing Script', cursive; 
      font-size: 1rem; 
      color: var(--pink-deep); 
      text-align: center; 
      margin-bottom: 0.2rem; 
    }
    .kingdom-map { 
      width: 100%; 
      height: auto; 
      display: block; 
    }
    .map-legend { 
      text-align: center; 
      font-size: 0.7rem; 
      color: var(--text-light); 
      margin-top: 0.3rem; 
      font-style: italic; 
    }

    #loading-screen { position: fixed; inset: 0; background: linear-gradient(135deg, var(--pink-light) 0%, var(--lavender) 50%, var(--sky) 100%); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 900; transition: opacity 0.5s ease, visibility 0.5s ease; }
    #loading-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
    .loading-crown { font-size: 4rem; animation: bounce 1s ease-in-out infinite; }
    .loading-text { font-family: 'Dancing Script', cursive; font-size: 1.8rem; color: var(--text-dark); margin-top: 1rem; text-shadow: 2px 2px 0 var(--white); }
    .loading-subtext { font-size: 0.9rem; color: var(--text-light); margin-top: 0.5rem; font-style: italic; }
    .loading-dots { display: flex; gap: 0.5rem; margin-top: 1.5rem; }
    .loading-dots span { width: 12px; height: 12px; background: var(--pink-main); border-radius: 50%; animation: dotPulse 1.4s ease-in-out infinite; }
    .loading-dots span:nth-child(2) { animation-delay: 0.2s; }
    .loading-dots span:nth-child(3) { animation-delay: 0.4s; }
    @keyframes bounce { 0%, 100% { transform: translateY(0) rotate(-5deg); } 50% { transform: translateY(-20px) rotate(5deg); } }
    @keyframes dotPulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(0.5); opacity: 0.5; } }

    #hud { position: fixed; top: 0; left: 0; right: 0; padding: 1rem; display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; z-index: 100; }
    .hud-left, .hud-right { pointer-events: auto; }
    .location-badge { background: rgba(255,255,255,0.9); backdrop-filter: blur(15px); padding: 0.6rem 1rem; border-radius: 2rem; box-shadow: 0 4px 20px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 0.5rem; font-weight: 600; color: var(--text-dark); font-size: 0.9rem; border: 2px solid rgba(255,255,255,0.5); }
    .location-icon { font-size: 1.2rem; }
    .progress-container { background: rgba(255,255,255,0.9); backdrop-filter: blur(15px); padding: 0.6rem 1rem; border-radius: 2rem; box-shadow: 0 4px 20px rgba(0,0,0,0.1); border: 2px solid rgba(255,255,255,0.5); }
    .progress-stars { display: flex; gap: 0.3rem; font-size: 1.2rem; }
    .star { opacity: 0.3; transition: all 0.3s ease; filter: grayscale(1); }
    .star.collected { opacity: 1; filter: grayscale(0); animation: starPop 0.5s ease; }
    @keyframes starPop { 0% { transform: scale(1) rotate(0deg); } 50% { transform: scale(1.5) rotate(180deg); } 100% { transform: scale(1) rotate(360deg); } }
    .collectibles-badge { background: rgba(255,255,255,0.9); backdrop-filter: blur(15px); padding: 0.5rem 0.8rem; border-radius: 1.5rem; box-shadow: 0 4px 20px rgba(0,0,0,0.1); display: flex; align-items: center; gap: 0.4rem; font-weight: 600; color: var(--text-dark); font-size: 0.85rem; margin-top: 0.5rem; border: 2px solid rgba(255,215,0,0.3); }
    .music-controls { margin-top: 0.6rem; background: rgba(255,255,255,0.9); backdrop-filter: blur(12px); border-radius: 1.2rem; padding: 0.5rem 0.7rem; box-shadow: 0 4px 18px rgba(0,0,0,0.1); border: 2px solid rgba(255,255,255,0.5); display: flex; flex-direction: column; gap: 0.4rem; }
    .music-title { font-size: 0.75rem; color: var(--text-light); text-align: center; }
    .music-track { font-size: 0.8rem; font-weight: 600; color: var(--text-dark); text-align: center; }
    .music-buttons { display: flex; gap: 0.4rem; justify-content: center; }
    .music-btn { background: linear-gradient(135deg, var(--pink-light) 0%, var(--lavender) 100%); border: none; color: var(--text-dark); font-size: 0.85rem; font-weight: 600; padding: 0.35rem 0.6rem; border-radius: 0.7rem; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
    .music-btn:active { transform: scale(0.95); }

    #joystick-container { position: fixed; bottom: 8rem; left: 2rem; width: 110px; height: 110px; z-index: 100; }
    #joystick-base { position: absolute; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.7) 100%); border: 3px solid var(--pink-main); border-radius: 50%; box-shadow: 0 4px 25px rgba(0,0,0,0.15), inset 0 2px 15px rgba(255,255,255,0.8); }
    #joystick-thumb { position: absolute; width: 45px; height: 45px; background: linear-gradient(135deg, var(--pink-main) 0%, var(--pink-deep) 100%); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 15px rgba(245, 161, 192, 0.6); transition: transform 0.05s ease-out; }

    #action-btn { position: fixed; bottom: 8rem; right: 2rem; background: linear-gradient(135deg, var(--mint) 0%, var(--mint-dark) 100%); border: none; border-radius: 2rem; padding: 1rem 1.5rem; font-family: 'Inter', sans-serif; font-weight: 700; font-size: 1rem; color: var(--white); box-shadow: 0 6px 25px rgba(184, 233, 134, 0.5); cursor: pointer; z-index: 150; display: none; align-items: center; gap: 0.5rem; transition: all 0.3s ease; animation: actionPulse 2s ease-in-out infinite; touch-action: manipulation; pointer-events: auto; }
    #action-btn.visible { display: flex; }
    #action-btn:active { transform: scale(0.95); }
    @keyframes actionPulse { 0%, 100% { box-shadow: 0 6px 25px rgba(184, 233, 134, 0.5); transform: translateY(0); } 50% { box-shadow: 0 8px 35px rgba(184, 233, 134, 0.8); transform: translateY(-3px); } }

    #dialog-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); backdrop-filter: blur(5px); display: none; align-items: flex-end; justify-content: center; z-index: 200; padding: 1rem; }
    #dialog-overlay.visible { display: flex; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    #dialog-box { background: var(--white); border-radius: 1.5rem; padding: 1.5rem; max-width: 400px; width: 100%; max-height: 70vh; overflow-y: auto; box-shadow: 0 -10px 50px rgba(0,0,0,0.25); animation: slideUp 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); position: relative; }
    @keyframes slideUp { from { transform: translateY(100%); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    .dialog-header { display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 2px dashed var(--pink-light); }
    .dialog-avatar { width: 60px; height: 60px; background: linear-gradient(135deg, var(--pink-light) 0%, var(--lavender) 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2rem; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
    .dialog-speaker { flex: 1; }
    .dialog-name { font-family: 'Dancing Script', cursive; font-size: 1.4rem; color: var(--text-dark); }
    .dialog-role { font-size: 0.85rem; color: var(--text-light); margin-top: 0.2rem; }
    .dialog-content { color: var(--text-dark); line-height: 1.7; font-size: 1rem; }
    .dialog-content h3 { font-family: 'Dancing Script', cursive; color: var(--pink-deep); margin: 1rem 0 0.5rem; font-size: 1.3rem; }
    .dialog-content ul { list-style: none; padding: 0; }
    .dialog-content li { padding: 0.5rem 0; padding-left: 1.5rem; position: relative; }
    .dialog-content li::before { content: '‚úø'; position: absolute; left: 0; color: var(--pink-main); }
    .dialog-content .highlight { background: linear-gradient(120deg, var(--pink-light) 0%, var(--lavender) 100%); padding: 0.2rem 0.5rem; border-radius: 0.3rem; font-weight: 600; }
    .dialog-content .detail-card { background: var(--cream); border-radius: 1rem; padding: 1rem; margin: 0.8rem 0; border-left: 4px solid var(--pink-main); }
    .dialog-content .detail-row { display: flex; align-items: center; gap: 0.5rem; padding: 0.4rem 0; }
    .dialog-content .detail-icon { font-size: 1.2rem; }
    .dialog-content .funny-quote { background: linear-gradient(135deg, var(--sky) 0%, var(--lavender) 100%); border-radius: 1rem; padding: 1rem; margin: 1rem 0; font-style: italic; text-align: center; }
    .dialog-close { position: absolute; top: 1rem; right: 1rem; width: 36px; height: 36px; background: var(--pink-light); border: none; border-radius: 50%; font-size: 1.2rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s ease; }
    .dialog-close:active { background: var(--pink-main); color: var(--white); }
    .guest-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; margin-top: 0.5rem; }
    .guest-item { background: var(--cream); padding: 0.5rem 0.8rem; border-radius: 0.5rem; font-size: 0.85rem; display: flex; align-items: center; gap: 0.3rem; }
    .speaker-card { background: linear-gradient(135deg, var(--cream) 0%, var(--pink-light) 100%); border-radius: 1rem; padding: 1rem; margin: 0.8rem 0; }
    .speaker-name { font-family: 'Dancing Script', cursive; color: var(--pink-deep); font-size: 1.2rem; }
    .speaker-topic { color: var(--text-light); font-size: 0.9rem; margin-top: 0.3rem; font-style: italic; }

    #minimap { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.95); backdrop-filter: blur(15px); padding: 0.8rem 1.5rem; border-radius: 2rem; box-shadow: 0 4px 20px rgba(0,0,0,0.1); display: flex; gap: 0.8rem; z-index: 90; border: 2px solid rgba(255,255,255,0.5); }
    .map-icon { width: 38px; height: 38px; background: var(--pink-light); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; cursor: pointer; transition: all 0.3s ease; opacity: 0.5; }
    .map-icon.visited { opacity: 1; background: linear-gradient(135deg, var(--pink-main) 0%, var(--lavender) 100%); }
    .map-icon.current { transform: scale(1.2); box-shadow: 0 0 20px rgba(245, 161, 192, 0.7); }

    #completion-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); display: none; align-items: center; justify-content: center; z-index: 400; padding: 1.5rem; }
    #completion-modal.visible { display: flex; }
    .completion-content { background: linear-gradient(135deg, var(--white) 0%, var(--cream) 100%); border-radius: 2rem; padding: 2rem; max-width: 350px; text-align: center; animation: bounceIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1); box-shadow: 0 20px 60px rgba(0,0,0,0.3); position: relative; }
    @keyframes bounceIn { 0% { transform: scale(0.3) rotate(-10deg); opacity: 0; } 50% { transform: scale(1.05) rotate(2deg); } 100% { transform: scale(1) rotate(0deg); opacity: 1; } }
    .completion-crown { font-size: 5rem; animation: crownFloat 3s ease-in-out infinite; }
    @keyframes crownFloat { 0%, 100% { transform: translateY(0) rotate(-3deg); } 50% { transform: translateY(-15px) rotate(3deg); } }
    .completion-title { font-family: 'Dancing Script', cursive; font-size: 1.8rem; color: var(--pink-deep); margin: 1rem 0; }
    .completion-text { color: var(--text-dark); line-height: 1.7; margin-bottom: 1.5rem; }
    .rsvp-section { background: linear-gradient(135deg, var(--pink-light) 0%, var(--lavender) 100%); border-radius: 1rem; padding: 1.2rem; margin-top: 1rem; }
    .rsvp-title { font-family: 'Dancing Script', cursive; font-weight: 700; color: var(--text-dark); margin-bottom: 0.5rem; font-size: 1.2rem; }

    #intro-modal { position: fixed; inset: 0; background: rgba(0,0,0,0.45); backdrop-filter: blur(6px); display: none; align-items: center; justify-content: center; z-index: 350; padding: 1.5rem; }
    #intro-modal.visible { display: flex; animation: fadeIn 0.3s ease; }
    .intro-card { background: linear-gradient(135deg, var(--white) 0%, var(--cream) 100%); border-radius: 1.5rem; padding: 1.6rem; max-width: 320px; text-align: center; box-shadow: 0 16px 40px rgba(0,0,0,0.25); }
    .intro-title { font-family: 'Dancing Script', cursive; font-size: 1.6rem; color: var(--pink-deep); margin-bottom: 0.6rem; }
    .intro-text { color: var(--text-dark); font-size: 0.92rem; line-height: 1.5; }
    .intro-text span { color: var(--pink-deep); font-weight: 600; }
    .intro-btn { margin-top: 1rem; background: linear-gradient(135deg, var(--mint) 0%, var(--mint-dark) 100%); border: none; color: var(--white); font-weight: 700; padding: 0.7rem 1.6rem; border-radius: 2rem; cursor: pointer; box-shadow: 0 6px 18px rgba(158, 211, 106, 0.5); }
    .intro-toggle { margin-top: 1rem; padding: 0.8rem; background: rgba(255,255,255,0.8); border-radius: 1rem; box-shadow: inset 0 0 0 1px rgba(245, 161, 192, 0.4); display: none; }
    .intro-toggle.visible { display: block; }
    .intro-toggle-title { font-weight: 700; color: var(--text-dark); margin-bottom: 0.4rem; }
    .intro-toggle-label { display: flex; align-items: center; gap: 0.6rem; font-size: 0.85rem; color: var(--text-light); justify-content: center; }
    .intro-toggle-label input { accent-color: var(--pink-main); width: 18px; height: 18px; }
    .is-hidden { display: none !important; }
    #keyboard-hints { position: fixed; bottom: 8rem; left: 2rem; padding: 0.6rem 0.9rem; background: rgba(255,255,255,0.95); border-radius: 1rem; box-shadow: 0 6px 20px rgba(0,0,0,0.15); font-size: 0.85rem; color: var(--text-dark); z-index: 100; display: none; max-width: 200px; text-align: left; }
    #keyboard-hints.visible { display: block; }

    #sweet-intro { position: fixed; inset: 0; background: rgba(0,0,0,0.4); backdrop-filter: blur(6px); display: none; align-items: center; justify-content: center; z-index: 360; padding: 1.5rem; }
    #sweet-intro.visible { display: flex; animation: fadeIn 0.3s ease; }
    .sweet-card { background: linear-gradient(135deg, var(--white) 0%, var(--cream) 100%); border-radius: 1.4rem; padding: 1.4rem; max-width: 300px; text-align: center; box-shadow: 0 16px 40px rgba(0,0,0,0.25); }
    .sweet-title { font-family: 'Dancing Script', cursive; font-size: 1.5rem; color: var(--pink-deep); margin-bottom: 0.5rem; }
    .sweet-text { color: var(--text-dark); font-size: 0.9rem; line-height: 1.5; }
    .sweet-text span { color: var(--pink-deep); font-weight: 600; }
    .sweet-btn { margin-top: 0.9rem; background: linear-gradient(135deg, var(--mint) 0%, var(--mint-dark) 100%); border: none; color: var(--white); font-weight: 700; padding: 0.6rem 1.4rem; border-radius: 2rem; cursor: pointer; box-shadow: 0 6px 18px rgba(158, 211, 106, 0.5); }

    .floating-message { position: fixed; background: var(--white); padding: 0.6rem 1rem; border-radius: 1rem; box-shadow: 0 4px 15px rgba(0,0,0,0.15); font-size: 0.85rem; color: var(--text-dark); z-index: 80; animation: floatMsg 3s ease-in-out forwards; pointer-events: none; max-width: 200px; }
    .floating-message::after { content: ''; position: absolute; bottom: -8px; left: 20px; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid var(--white); }
    @keyframes floatMsg { 0% { opacity: 0; transform: translateY(10px); } 10% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; transform: translateY(-20px); } }

    .collect-popup { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, var(--gold) 0%, var(--peach) 100%); padding: 1rem 2rem; border-radius: 2rem; font-weight: 700; color: var(--text-dark); z-index: 150; animation: collectPop 1s ease-out forwards; box-shadow: 0 8px 30px rgba(255,215,0,0.4); }
    @keyframes collectPop { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 30% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 50% { transform: translate(-50%, -50%) scale(1); } 100% { transform: translate(-50%, -100%) scale(0.8); opacity: 0; } }

    .mission-notif { position: fixed; top: 1rem; right: 1rem; background: linear-gradient(135deg, var(--mint) 0%, var(--lavender) 100%); padding: 0.8rem 1.2rem; border-radius: 1rem; font-weight: 600; color: var(--text-dark); z-index: 160; animation: slideInRight 3s ease-out forwards; box-shadow: 0 4px 20px rgba(0,0,0,0.2); max-width: 200px; text-align: center; font-size: 0.9rem; }
    .mission-notif-icon { font-size: 1.5rem; display: block; margin-bottom: 0.3rem; }
    @keyframes slideInRight { 0% { transform: translateX(120%); opacity: 0; } 10% { transform: translateX(0); opacity: 1; } 85% { transform: translateX(0); opacity: 1; } 100% { transform: translateX(120%); opacity: 0; } }

    @media (max-width: 380px) {
      .splash-title { font-size: 2.2rem; }
      .splash-crown { font-size: 4.5rem; }
      #minimap { padding: 0.6rem 1rem; gap: 0.5rem; }
      .map-icon { width: 32px; height: 32px; font-size: 1rem; }
    }
  </style>
</head>
<body>
  <div id="splash-screen">
    <div class="splash-sparkle" style="top: 10%; left: 15%;">‚ú®</div>
    <div class="splash-sparkle" style="top: 20%; right: 20%; animation-delay: 0.5s;">‚≠ê</div>
    <div class="splash-sparkle" style="top: 60%; left: 10%; animation-delay: 1s;">üí´</div>
    <div class="splash-sparkle" style="top: 70%; right: 15%; animation-delay: 1.5s;">‚ú®</div>
    <div class="splash-sparkle" style="top: 40%; left: 25%; animation-delay: 2s;">üåü</div>
    <div class="splash-crown-container">
      <div class="splash-glow"></div>
      <div class="splash-crown">üëë</div>
    </div>
    <div class="splash-title">The Royal Court Tea</div>
    <div class="splash-subtitle">‚ú® Unapologetically Royal ‚ú®</div>
    <div class="splash-tagline">Embracing Your Crown</div>
    <div class="splash-instruction">
      <p>You've been summoned to a <strong>royal adventure!</strong></p>
      <p style="margin-top: 0.5rem;">Explore the kingdom, meet quirky characters, and discover the tea party secrets! üçµ</p>
    </div>
    
    <div class="splash-map" id="splash-map">
      <div class="map-title">‚ú® The Royal Kingdom ‚ú®</div>
      <svg viewBox="0 0 300 220" class="kingdom-map">
        <!-- Background -->
        <ellipse cx="150" cy="115" rx="140" ry="100" fill="#c8f7c5" stroke="#7cb77c" stroke-width="2"/>
        
        <!-- Grass texture details (visible when zoomed) -->
        <circle cx="50" cy="90" r="3" fill="#a8e6a8" opacity="0.6"/>
        <circle cx="250" cy="90" r="3" fill="#a8e6a8" opacity="0.6"/>
        <circle cx="80" cy="140" r="2" fill="#a8e6a8" opacity="0.6"/>
        <circle cx="220" cy="140" r="2" fill="#a8e6a8" opacity="0.6"/>
        <circle cx="150" cy="180" r="3" fill="#a8e6a8" opacity="0.6"/>
        
        <!-- Paths -->
        <path d="M150 115 L150 45" stroke="#f5deb3" stroke-width="8" stroke-linecap="round"/>
        <path d="M150 115 L230 85" stroke="#f5deb3" stroke-width="8" stroke-linecap="round"/>
        <path d="M150 115 L210 165" stroke="#f5deb3" stroke-width="8" stroke-linecap="round"/>
        <path d="M150 115 L90 165" stroke="#f5deb3" stroke-width="8" stroke-linecap="round"/>
        <path d="M150 115 L70 85" stroke="#f5deb3" stroke-width="8" stroke-linecap="round"/>
        
        <!-- Path details (stepping stones) -->
        <circle cx="150" cy="80" r="2" fill="#e6d5a8"/>
        <circle cx="150" cy="60" r="2" fill="#e6d5a8"/>
        <circle cx="190" cy="100" r="2" fill="#e6d5a8"/>
        <circle cx="215" cy="90" r="2" fill="#e6d5a8"/>
        <circle cx="180" cy="140" r="2" fill="#e6d5a8"/>
        <circle cx="195" cy="155" r="2" fill="#e6d5a8"/>
        <circle cx="120" cy="140" r="2" fill="#e6d5a8"/>
        <circle cx="105" cy="155" r="2" fill="#e6d5a8"/>
        <circle cx="110" cy="100" r="2" fill="#e6d5a8"/>
        <circle cx="85" cy="90" r="2" fill="#e6d5a8"/>
        
        <!-- Center fountain -->
        <circle cx="150" cy="115" r="15" fill="#87ceeb" stroke="#5cacee" stroke-width="2"/>
        <circle cx="150" cy="115" r="10" fill="#a8d8ea" opacity="0.5"/>
        <text x="150" y="120" text-anchor="middle" font-size="14">‚õ≤</text>
        
        <!-- Palace - Top (Queen Bee) -->
        <g transform="translate(150, 35)">
          <rect x="-25" y="-20" width="50" height="35" rx="5" fill="#f5a1c0" stroke="#e87aa0" stroke-width="2"/>
          <rect x="-20" y="-15" width="10" height="12" rx="2" fill="#ffb6c1" opacity="0.5"/>
          <rect x="10" y="-15" width="10" height="12" rx="2" fill="#ffb6c1" opacity="0.5"/>
          <text x="0" y="5" text-anchor="middle" font-size="20">üè∞</text>
          <text x="0" y="28" text-anchor="middle" font-size="8" fill="#4a3f5c" font-weight="bold">Queen Bee</text>
          <text x="30" y="-5" font-size="10">üêù</text>
          <text x="-30" y="0" font-size="8">üêù</text>
          <circle cx="35" cy="10" r="4" fill="#ffc61a" opacity="0.7"/>
          <text x="35" y="12" text-anchor="middle" font-size="5">üçØ</text>
        </g>
        
        <!-- Tea Garden - Right Top -->
        <g transform="translate(235, 75)">
          <rect x="-22" y="-18" width="44" height="32" rx="5" fill="#a9c7ff" stroke="#7aa8e6" stroke-width="2"/>
          <text x="0" y="3" text-anchor="middle" font-size="18">üçµ</text>
          <text x="0" y="26" text-anchor="middle" font-size="7" fill="#4a3f5c" font-weight="bold">Lady Phebe</text>
          <text x="-18" y="-8" font-size="6">‚òï</text>
        </g>
        
        <!-- Speakers - Right Bottom -->
        <g transform="translate(215, 170)">
          <rect x="-25" y="-18" width="50" height="32" rx="5" fill="#d4b8ff" stroke="#b89fe6" stroke-width="2"/>
          <text x="0" y="3" text-anchor="middle" font-size="18">üé§</text>
          <text x="0" y="26" text-anchor="middle" font-size="6" fill="#4a3f5c" font-weight="bold">Princess Bernie</text>
          <text x="-20" y="-8" font-size="6">üéµ</text>
          <text x="18" y="-8" font-size="6">üé∂</text>
        </g>
        
        <!-- Guests - Left Bottom -->
        <g transform="translate(85, 170)">
          <rect x="-22" y="-18" width="44" height="32" rx="5" fill="#ffd4a8" stroke="#e6b88a" stroke-width="2"/>
          <text x="0" y="3" text-anchor="middle" font-size="18">üìú</text>
          <text x="0" y="26" text-anchor="middle" font-size="7" fill="#4a3f5c" font-weight="bold">Lord Scribe</text>
          <text x="-18" y="-8" font-size="6">‚úíÔ∏è</text>
        </g>
        
        <!-- Feast Hall - Left Top -->
        <g transform="translate(65, 75)">
          <rect x="-22" y="-18" width="44" height="32" rx="5" fill="#b8e986" stroke="#9ed36a" stroke-width="2"/>
          <text x="0" y="3" text-anchor="middle" font-size="18">üç∞</text>
          <text x="0" y="26" text-anchor="middle" font-size="7" fill="#4a3f5c" font-weight="bold">Chef Caron</text>
          <text x="18" y="-8" font-size="6">üßÅ</text>
        </g>
        
        <!-- Player start indicator -->
        <g transform="translate(150, 145)">
          <circle cx="0" cy="0" r="12" fill="#fff0f5" stroke="#f5a1c0" stroke-width="2" stroke-dasharray="3,2"/>
          <circle cx="0" cy="0" r="8" fill="#ffd1e1"/>
          <text x="0" y="4" text-anchor="middle" font-size="10">üë∏</text>
          <text x="0" y="22" text-anchor="middle" font-size="6" fill="#e87aa0" font-weight="bold">YOU START HERE!</text>
        </g>
        
        <!-- Wandering NPCs hint -->
        <g transform="translate(115, 85)">
          <circle cx="0" cy="0" r="5" fill="#ffc0cb" opacity="0.8"/>
          <text x="0" y="3" text-anchor="middle" font-size="6">üö∂</text>
        </g>
        <g transform="translate(185, 135)">
          <circle cx="0" cy="0" r="5" fill="#add8e6" opacity="0.8"/>
          <text x="0" y="3" text-anchor="middle" font-size="6">üèÉ</text>
        </g>
        
        <!-- Decorative elements -->
        <text x="40" y="130" font-size="12">üå∏</text>
        <text x="260" y="130" font-size="12">üå∑</text>
        <text x="150" y="200" font-size="10">üåª</text>
        <text x="100" y="50" font-size="10">ü¶ã</text>
        <text x="200" y="50" font-size="10">üå∫</text>
        <text x="30" y="70" font-size="8">üåº</text>
        <text x="270" y="160" font-size="8">üåπ</text>
        <text x="130" y="205" font-size="6">üêõ</text>
        <text x="170" y="205" font-size="6">üêû</text>
        
        <!-- Trees -->
        <text x="25" y="110" font-size="14">üå≥</text>
        <text x="275" y="110" font-size="14">üå≤</text>
      </svg>
      <div class="map-legend">
        <span>üéØ Visit all 5 locations to complete the quest!</span>
      </div>
      <div class="map-tap-hint">üëÜ Tap to enlarge</div>
      <div class="map-close-hint">üëÜ Tap anywhere to close</div>
    </div>
    
    <button class="splash-btn" id="start-btn">Enter the Kingdom ‚ú®</button>
    <div class="splash-footer">Made with üç∞‚ù§Ô∏è by William</div>
  </div>
  
  <div class="map-overlay" id="map-overlay"></div>

  <div id="loading-screen" class="hidden">
    <div class="loading-crown">üëë</div>
    <div class="loading-text">Preparing Your Kingdom...</div>
    <div class="loading-subtext">Polishing crowns & brewing tea</div>
    <div class="loading-dots"><span></span><span></span><span></span></div>
  </div>

  <div id="intro-modal">
    <div class="intro-card">
      <div class="intro-title">Welcome, Royal One ‚ú®</div>
      <div class="intro-text">
        Glide with the joystick, tap characters to chat, and follow the paths.<br>
        Start with <span>Queen Bee</span> if you want, then explore all five spots, collect sweets, and soak up the vibes.<br>
        Most importantly: chill and have fun. üå∏
      </div>
      <div class="intro-toggle" id="desktop-mode-section">
        <div class="intro-toggle-title">Desktop Mode</div>
        <label class="intro-toggle-label">
          <input type="checkbox" id="desktop-mode-toggle">
          <span>Enable keyboard controls</span>
        </label>
      </div>
      <button class="intro-btn" id="intro-start">Let's stroll üëë</button>
    </div>
  </div>

  <div id="sweet-intro">
    <div class="sweet-card">
      <div class="sweet-title">Sweets Power-Up üç¨</div>
      <div class="sweet-text">
        You found your first treat! Sweets give you a <span>speed boost</span> for a short time.
        Grab more for extra sparkle and speed.
      </div>
      <button class="sweet-btn" id="sweet-dismiss">Got it ‚ú®</button>
    </div>
  </div>

  <div id="game-container"></div>

  <div id="hud">
    <div class="hud-left">
      <div class="location-badge">
        <span class="location-icon" id="location-icon">üè∞</span>
        <span id="location-name">Royal Village</span>
      </div>
      <div class="collectibles-badge">
        <span>üç¨</span><span id="collectible-count">0</span><span style="opacity:0.6">/</span><span id="collectible-total">0</span>
      </div>
    </div>
    <div class="hud-right">
      <div class="progress-container">
        <div class="progress-stars">
          <span class="star" id="star-0">‚≠ê</span><span class="star" id="star-1">‚≠ê</span><span class="star" id="star-2">‚≠ê</span><span class="star" id="star-3">‚≠ê</span><span class="star" id="star-4">‚≠ê</span>
        </div>
      </div>
      <div class="music-controls">
        <div class="music-title">üéµ Royal Playlist</div>
        <div class="music-track" id="music-track">Ready to play</div>
        <div class="music-buttons">
          <button class="music-btn" id="music-toggle">üîà Sound On</button>
          <button class="music-btn" id="music-next">‚è≠Ô∏è Next</button>
        </div>
      </div>
    </div>
  </div>

  <div id="joystick-container"><div id="joystick-base"><div id="joystick-thumb"></div></div></div>
  <button id="action-btn"><span>üí¨</span><span>Tap to Chat</span></button>
  <div id="keyboard-hints">WASD for movement. P for interaction.</div>

  <div id="minimap">
    <div class="map-icon current" data-location="palace">üè∞</div>
    <div class="map-icon" data-location="teashop">üçµ</div>
    <div class="map-icon" data-location="speakers">üé§</div>
    <div class="map-icon" data-location="guests">üìú</div>
    <div class="map-icon" data-location="feast">üç∞</div>
  </div>

  <div id="dialog-overlay">
    <div id="dialog-box">
      <button class="dialog-close" id="dialog-close">‚úï</button>
      <div class="dialog-header">
        <div class="dialog-avatar" id="dialog-avatar">üë∏</div>
        <div class="dialog-speaker">
          <div class="dialog-name" id="dialog-name">Princess</div>
          <div class="dialog-role" id="dialog-role">Royal Guide</div>
        </div>
      </div>
      <div class="dialog-content" id="dialog-content"></div>
    </div>
  </div>

  <div id="completion-modal">
    <div class="completion-content">
      <button class="dialog-close" id="completion-close">‚úï</button>
      <div class="completion-crown">üëë</div>
      <div class="completion-title">You Did It, Royal One!</div>
      <div class="completion-text">You've explored the entire kingdom!<br><br>We can't wait to see you at <strong>The Royal Court Tea</strong>! üëó‚ú®</div>
      <div class="rsvp-section">
        <div class="rsvp-title">üìç Save the Date!</div>
        <div style="font-weight: 600;">Saturday, 31 January 2026</div>
        <div>11:00 AM</div>
        <div style="font-size: 0.85rem; margin-top: 0.5rem; opacity: 0.9;">146 Heather Rd, Austinville, Blackheath</div>
      </div>
      <button class="splash-btn" id="continue-btn" style="margin-top: 1.5rem; padding: 0.8rem 2rem; font-size: 1rem;">Keep Exploring üëë</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================
    // üéµ VOICE SYSTEM - Cute NPC voices!
    // ============================================
    const VOICE_FILES = {
      palace: 'voices/Voice1.mp3',  // Queen Bee ALWAYS gets Voice1
      teashop: ['voices/Voice2.mp3', 'voices/Voice3.mp3', 'voices/Voice4.mp3', 'voices/Voice5.mp3', 'voices/Voice6.mp3', 'voices/Voice7.mp3'],
      speakers: ['voices/Voice2.mp3', 'voices/Voice3.mp3', 'voices/Voice4.mp3', 'voices/Voice5.mp3', 'voices/Voice6.mp3', 'voices/Voice7.mp3'],
      guests: ['voices/Voice2.mp3', 'voices/Voice3.mp3', 'voices/Voice4.mp3', 'voices/Voice5.mp3', 'voices/Voice6.mp3', 'voices/Voice7.mp3'],
      feast: ['voices/Voice2.mp3', 'voices/Voice3.mp3', 'voices/Voice4.mp3', 'voices/Voice5.mp3', 'voices/Voice6.mp3', 'voices/Voice7.mp3'],
      wanderer: ['voices/Voice2.mp3', 'voices/Voice3.mp3', 'voices/Voice4.mp3', 'voices/Voice5.mp3', 'voices/Voice6.mp3', 'voices/Voice7.mp3']
    };
    const AMBIENT_VOICE_MIN_DELAY = 10000;
    const AMBIENT_VOICE_MAX_DELAY = 10000;
    const WANDERER_VOICE_COOLDOWN = 10000;
    let lastWandererVoiceAt = 0;

    function playVoice(locationId) {
      try {
        const voiceFile = VOICE_FILES[locationId];
        if (!voiceFile) return;

        const voicePath = Array.isArray(voiceFile)
          ? voiceFile[Math.floor(Math.random() * voiceFile.length)]
          : voiceFile;

        const audio = new Audio(voicePath);
        audio.volume = 0.6;
        audio.play().catch(err => console.log('Voice playback prevented:', err));
      } catch (err) {
        console.log('Voice error:', err);
      }
    }

    function playRandomWandererVoice() {
      try {
        const now = Date.now();
        if (now - lastWandererVoiceAt < WANDERER_VOICE_COOLDOWN) {
          return;
        }
        lastWandererVoiceAt = now;

        const voices = VOICE_FILES.wanderer;
        const randomVoice = voices[Math.floor(Math.random() * voices.length)];
        const audio = new Audio(randomVoice);
        audio.volume = 0.5;
        audio.play().catch(err => console.log('Voice playback prevented:', err));
      } catch (err) {
        console.log('Voice error:', err);
      }
    }

    function scheduleNextAmbientVoice(npc, now = Date.now()) {
      npc.userData.nextVoiceTime = now + AMBIENT_VOICE_MIN_DELAY +
        Math.random() * (AMBIENT_VOICE_MAX_DELAY - AMBIENT_VOICE_MIN_DELAY);
    }

    function maybePlayAmbientVoice(npc) {
      const now = Date.now();
      if (!npc.userData.nextVoiceTime) {
        scheduleNextAmbientVoice(npc, now);
        return;
      }
      if (now >= npc.userData.nextVoiceTime) {
        playRandomWandererVoice();
        scheduleNextAmbientVoice(npc, now);
      }
    }

    // Event data
    const EVENT = {
      title: "The Royal Court Tea",
      subtitle: "Unapologetically Royal",
      tagline: "Embracing your crown",
      date: "Saturday, 31 January 2026",
      time: "11:00 AM",
      location: "146 Heather Rd, Austinville, Blackheath",
      dressCode: "Royal (floral and pastel colours)"
    };
    const SPEAKERS = [
      { name: "Sister Lucille", topic: "Me, Myself and I" },
      { name: "Sister Lizelle", topic: "The Importance of Friendship/Sisterhood" },
      { name: "Sister Mariana", topic: "Living for Christ and being the example" }
    ];
    const GUESTS = ["Bernily King", "Caron Benjamin", "Phebe Benjamin", "Ruth-Grace Davids", "Victory Strauss", "Aurelia Botha", "Zoe Kabwanga", "Tamlyn Okkers", "Carla Okkers", "Nicole Heuvel", "Kaylen Heuvel", "Sharidyn Rogers", "Chelsea Latola", "Beaulah Davids"];

    // Location data
    const LOCATIONS = [
      { id: 'palace', x: 0, z: -14, color: 0xf5a1c0, icon: 'üè∞', name: 'Royal Palace', sx: 5, sz: 4 },
      { id: 'teashop', x: 12, z: -4, color: 0xa9c7ff, icon: 'üçµ', name: 'Tea Garden', sx: 4, sz: 3.5 },
      { id: 'speakers', x: 8, z: 11, color: 0xd4b8ff, icon: 'üé§', name: "Speaker's Grove", sx: 5, sz: 5 },
      { id: 'guests', x: -8, z: 11, color: 0xffd4a8, icon: 'üìú', name: 'Guest Registry', sx: 4, sz: 4 },
      { id: 'feast', x: -12, z: -4, color: 0xb8e986, icon: 'üç∞', name: 'Feast Hall', sx: 4.5, sz: 3.5 }
    ];

    // Dialog content
    const DIALOGS = {
      palace: {
        avatar: "üë∏",
        name: "Queen Bee",
        role: "Royal Host & Professional Crown Wearer",
        content: `<h3>üëë ${EVENT.title}</h3><p style="font-family: 'Dancing Script', cursive; font-size: 1.4rem; color: var(--pink-deep); margin: 1rem 0;">"${EVENT.subtitle}"</p><p style="font-style: italic; color: var(--text-light);">${EVENT.tagline}</p><div class="funny-quote">Why fit in when you were born to stand out... in a tiara? üëëüêù</div><p style="margin-top: 1rem;">Welcome to the Royal Court! You have been specially chosen to attend our magnificent tea party.</p><p style="margin-top: 0.8rem;">Explore the kingdom to discover all the magical details. And try not to step on the royal corgis! üêï</p>`
      },
      teashop: {
        avatar: "üçµ",
        name: "Lady Phebe",
        role: "Tea Sommelier & Biscuit Enthusiast",
        content: `<h3>üìã Event Details</h3><div class="funny-quote">I've never met a problem that couldn't be solved with tea. Except running out of tea. That's a crisis.</div><div class="detail-card"><div class="detail-row"><span class="detail-icon">üìÖ</span><strong>${EVENT.date}</strong></div><div class="detail-row"><span class="detail-icon">‚è∞</span><strong>${EVENT.time}</strong></div><div class="detail-row"><span class="detail-icon">üìç</span><span>${EVENT.location}</span></div><div class="detail-row"><span class="detail-icon">üëó</span><span>Dress Code: <span class="highlight">${EVENT.dressCode}</span></span></div></div><p style="margin-top: 1rem;">Come dressed in your finest royal attire! Tiaras encouraged. Pajamas discouraged... unless they're ROYAL pajamas. üëë</p>`
      },
      speakers: {
        avatar: "üé§",
        name: "Princess Bernie",
        role: "Royal Announcer & Hype Lady",
        content: `<h3>üåü Guest Speakers</h3><div class="funny-quote">*clears throat dramatically*<br>HEAR YE, HEAR YE! Prepare to be INSPIRED! üì£</div><p>Our distinguished speakers will share wisdom:</p>${SPEAKERS.map(s => `<div class="speaker-card"><div class="speaker-name">üëë ${s.name}</div><div class="speaker-topic">"${s.topic}"</div></div>`).join('')}<p style="margin-top: 1rem; font-style: italic; color: var(--text-light);">Tissues provided. Prepare for tears AND laughter! üòÇüò≠</p>`
      },
      guests: {
        avatar: "üìú",
        name: "Lord Scribe",
        role: "Royal Registry Keeper & Name Speller",
        content: `<h3>üëë The Royal Court</h3><div class="funny-quote">I've written every name with my finest quill. My hand cramped. Worth it. ‚úçÔ∏è</div><p>These distinguished guests have been summoned:</p><div class="guest-grid">${GUESTS.map(g => `<div class="guest-item"><span>‚úø</span> ${g}</div>`).join('')}</div><p style="margin-top: 1rem; text-align: center;">If your name is here, you're basically royalty now! üíé</p>`
      },
      feast: {
        avatar: "üç∞",
        name: "Chef Caron",
        role: "Royal Baker & Professional Taste Tester",
        content: `<h3>üçΩÔ∏è A Royal Feast</h3><div class="funny-quote">My philosophy? Life is uncertain. Eat dessert first. üßÅ</div><p>Our tea party shall be a grand <span class="highlight">Potluck Celebration</span>!</p><div class="detail-card"><p><strong>Each guest is kindly asked to bring:</strong></p><ul><li>A dish fit for royalty to share</li><li>Your favorite tea-time treat</li><li>An appetite (very important!)</li><li>Your creative mind</li></ul></div><p style="margin-top: 1rem;">Pinkies out at a 45-degree angle. I will have a PROTRACTOR. üìê</p><p style="margin-top: 1rem; font-family: 'Dancing Script', cursive; font-size: 1.2rem; text-align: center; color: var(--pink-deep);">"Together we feast, together we reign!" üëë</p>`
      }
    };

    const PATH_CONFIG = {
      count: 5,
      angleStep: Math.PI * 0.4,
      length: 13,
      width: 2.5,
      centerRadius: 6.5
    };

    const WANDERING_NPCS = [
      // Regular wanderers
      { name: "Lady Giggles", role: "Royal Laugher", quotes: [
        "Why did the crown go to therapy? Too much pressure! *snort*",
        "I laugh at my own jokes. Excellent taste.",
        "Best. Job. Ever.",
        "Hahahaha! Wait, what were we talking about?",
        "My doctor says I laugh too much. I laughed at him too."
      ], speed: 'normal' },
      { name: "Duke Snackington", role: "Snack Ambassador", quotes: [
        "I'm not hoarding cookies. I'm... protecting them.",
        "The secret ingredient is always more butter.",
        "I've been to the feast hall 7 times today.",
        "Is it snack time yet? It's always snack time.",
        "Calories don't count at royal parties. It's the law."
      ], speed: 'normal' },
      { name: "Countess Sparkle", role: "Glitter Specialist", quotes: [
        "I put glitter in my coffee this morning. YOLO.",
        "Some say I use too much sparkle. They're jealous.",
        "My tiara has a tiara.",
        "I sneezed and now the garden is fabulous.",
        "Glitter is just aggressive confetti. I love it."
      ], speed: 'normal' },
      
      // Fast runners - silly and hyper
      { name: "Zippy Zoom", role: "Royal Sprinter", quotes: [
        "GOTTA GO FAST! Wait... why?",
        "I'm not running FROM something, I'm running TO... actually I forgot.",
        "WHEEEEE! *crashes into bush*",
        "Can't stop won't stop! ...okay maybe I'll stop.",
        "I RAN SO FAST I SAW TOMORROW!"
      ], speed: 'fast' },
      { name: "Princess Turbo", role: "Speed Enthusiast", quotes: [
        "Slow? I don't know her!",
        "I had 47 cups of tea this morning!",
        "ZOOM ZOOM ZOOOOOM!",
        "Racing the clouds! I'm winning!",
        "My legs are powered by EXCITEMENT!"
      ], speed: 'fast' },
      { name: "Lady Rocket", role: "Professional Rusher", quotes: [
        "Late for EVERYTHING! Even when I'm early!",
        "My legs said RUN so here we are!",
        "*whoooosh* Did you see me? I was a BLUR!",
        "No time to chat! Actually yes time! NO WAIT‚Äî",
        "I'm not hyper, I'm ENTHUSIASTICALLY ENERGETIC!"
      ], speed: 'fast' },
      
      // Slow elderly - complaining adorably
      { name: "Granny Shuffle", role: "Senior Stroller", quotes: [
        "Back in MY day, we walked even SLOWER.",
        "My knees are older than this kingdom.",
        "These young folk and their 'running'... disgraceful.",
        "I've been walking to the tea shop since Tuesday.",
        "Slow and steady wins the... what was I saying?"
      ], speed: 'slow' },
      { name: "Old Baron Creaky", role: "Vintage Walker", quotes: [
        "*creeeak* That was my back, not the floor.",
        "Ah, to be young and have working ankles...",
        "I remember when this was all fields... wait, it still is.",
        "Walking is exercise. I'm basically an athlete.",
        "My bones predict rain. Also sunshine. They're confused."
      ], speed: 'slow' },
      { name: "Duchess Dawdle", role: "Leisurely Lady", quotes: [
        "Rushing causes wrinkles, dear.",
        "I'll get there when I get there. Maybe tomorrow.",
        "My spirit animal is a sleepy tortoise.",
        "These bones have seen 400 tea parties. They're tired.",
        "In my day, we took NAP BREAKS during walks."
      ], speed: 'slow' },
      { name: "Sir Wobbles", role: "Professional Walker", quotes: [
        "I've been walking in circles for 3 days. Send help.",
        "Have you seen my other shoe?",
        "I'm not lost. I'm on an ADVENTURE.",
        "Left foot, right foot, left foot... wait, which was first?",
        "I meant to go this way. Definitely. On purpose."
      ], speed: 'normal' },
      { name: "Princess Oops", role: "Professional Accident Haver", quotes: [
        "I've tripped over 3 invisible things today. New record!",
        "Who put that wall there?!",
        "I'm not clumsy. The floor is just really friendly.",
        "*trips on nothing* I MEANT TO DO THAT.",
        "Gravity and I have a complicated relationship."
      ], speed: 'normal' },
      { name: "Baron Von Naps", role: "Royal Sleep Consultant", quotes: [
        "I'm not sleeping, I'm resting my eyes... horizontally.",
        "My spirit animal is a sloth wearing a crown.",
        "Napping is just practicing for being a statue.",
        "*yawns royally* Excuse me, that was a REGAL yawn.",
        "I dream of dreams about dreaming. Very productive."
      ], speed: 'slow' }
    ];

    const MUSIC_TRACKS = [
      { title: "Cloud Kingdom Caf√© Part I", file: "Cloud Kingdom Caf√© Part I.mp3" },
      { title: "Cloud Kingdom Caf√© Part II", file: "Cloud Kingdom Caf√© Part II.mp3" },
      { title: "Castle in the Clouds", file: "Castle in the Clouds.mp3" }
    ];

    // Game state
    const gameState = {
      started: false,
      dialogOpen: false,
      timeScale: 1,
      firstSweetShown: false,
      visited: new Set(),
      collected: 0,
      currentLocation: 'palace',
      nearNPC: null,
      nearWanderer: null,
      completionShown: false,
      bernieListenersActive: false,
      bernieListenersLeaving: false
    };

    // Three.js objects
    let scene, camera, renderer, player;
    const buildings = {};
    const npcs = {};
    const wanderers = [];
    const collectibles = [];
    const clouds = [];
    const bees = [];
    const bernieListeners = [];
    const corgis = [];
    const collisionBoxes = [];
    const celebrationParticles = [];
    let particleTexture;
    let lastCelebrationTime = 0;
    const CELEBRATION_COOLDOWN = 250;
    const BOOST_DURATION = 1500;
    const BASE_PLAYER_SPEED = 6;
    const BOOST_PLAYER_SPEED = 12;
    const clock = new THREE.Clock();
    const joystickInput = { x: 0, y: 0 };
    const keyboardInput = { x: 0, y: 0 };
    const keyboardState = { up: false, down: false, left: false, right: false };
    let desktopModeEnabled = false;
    const cameraTarget = new THREE.Vector3();
    const cameraZoomState = {
      currentOffset: 12,
      targetOffset: 12,
      baseOffset: 12,
      zoomedOutOffset: 15,
      zoomOutDelay: 0.35,
      zoomInDelay: 0.6,
      lastMoveChange: 0,
      moving: false
    };
    const musicAudio = new Audio();
    const musicState = {
      currentIndex: 0,
      muted: false,
      initialized: false
    };
    let corgiFurMaterial;
    let corgiAccentMaterial;

    function updateMusicUI() {
      const trackLabel = document.getElementById('music-track');
      const toggleBtn = document.getElementById('music-toggle');
      const track = MUSIC_TRACKS[musicState.currentIndex];
      trackLabel.textContent = track ? track.title : 'Ready to play';
      toggleBtn.textContent = musicAudio.muted ? 'üîá Muted' : 'üîà Sound On';
    }

    function loadTrack(index) {
      const track = MUSIC_TRACKS[index];
      if (!track) return;
      musicAudio.src = encodeURI(track.file);
      updateMusicUI();
    }

    function playCurrentTrack() {
      if (!musicAudio.src) {
        loadTrack(musicState.currentIndex);
      }
      musicAudio.play().catch(() => {});
    }

    function playNextTrack() {
      musicState.currentIndex = (musicState.currentIndex + 1) % MUSIC_TRACKS.length;
      loadTrack(musicState.currentIndex);
      playCurrentTrack();
    }

    function toggleMusicMute() {
      musicAudio.muted = !musicAudio.muted;
      updateMusicUI();
    }

    // Initialize game
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      scene.fog = new THREE.FogExp2(0xc8e8ff, 0.008);

      // Camera
      camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 14, 18);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: window.devicePixelRatio < 2 });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('game-container').appendChild(renderer.domElement);
      particleTexture = createParticleTexture();

      // Lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));
      
      const sun = new THREE.DirectionalLight(0xfff8e7, 0.6);
      sun.position.set(15, 25, 15);
      sun.castShadow = true;
      sun.shadow.mapSize.set(2048, 2048);
      sun.shadow.camera.near = 0.5;
      sun.shadow.camera.far = 80;
      sun.shadow.camera.left = -35;
      sun.shadow.camera.right = 35;
      sun.shadow.camera.top = 35;
      sun.shadow.camera.bottom = -35;
      sun.shadow.radius = 4;
      scene.add(sun);
      
      scene.add(new THREE.HemisphereLight(0x87ceeb, 0x98fb98, 0.3));

      // Build world
      createWorld();
      
      // Update collectible count
      document.getElementById('collectible-total').textContent = collectibles.length;

      // Event listeners
      window.addEventListener('resize', onResize);
      setupControls();

      musicAudio.volume = 0.5;
      musicAudio.addEventListener('ended', playNextTrack);
      loadTrack(musicState.currentIndex);
      updateMusicUI();

      // Start render loop
      animate();
    }

    function createWorld() {
      // Ground
      const groundGeo = new THREE.CircleGeometry(55, 64);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x90d860, roughness: 0.8 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Paths
      const pathMat = new THREE.MeshStandardMaterial({ color: 0xf5deb3, roughness: 0.9 });
      for (let i = 0; i < PATH_CONFIG.count; i++) {
        const angle = PATH_CONFIG.angleStep * i;
        const path = new THREE.Mesh(
          new THREE.PlaneGeometry(PATH_CONFIG.width, PATH_CONFIG.length),
          pathMat
        );
        path.rotation.x = -Math.PI / 2;
        path.rotation.z = -angle;
        path.position.set(
          Math.sin(angle) * PATH_CONFIG.centerRadius,
          0.02,
          Math.cos(angle) * PATH_CONFIG.centerRadius
        );
        path.receiveShadow = true;
        scene.add(path);
      }

      // Plaza
      const plaza = new THREE.Mesh(
        new THREE.CircleGeometry(5, 32),
        new THREE.MeshStandardMaterial({ color: 0xffd4a8, roughness: 0.7 })
      );
      plaza.rotation.x = -Math.PI / 2;
      plaza.position.y = 0.03;
      plaza.receiveShadow = true;
      scene.add(plaza);

      // Fountain
      createFountain();

      // Player
      createPlayer();

      // Buildings and NPCs
      LOCATIONS.forEach((loc, index) => {
        const building = createBuilding(loc.color, loc.id);
        building.position.set(loc.x, 0, loc.z);
        building.userData = { id: loc.id, icon: loc.icon, name: loc.name };
        scene.add(building);
        buildings[loc.id] = building;

        // Add collision box
        collisionBoxes.push({
          minX: loc.x - loc.sx / 2 - 0.5,
          maxX: loc.x + loc.sx / 2 + 0.5,
          minZ: loc.z - loc.sz / 2 - 0.5,
          maxZ: loc.z + loc.sz / 2 + 0.5
        });

        // Create NPC in front of building
        const npc = createNPC();
        npc.position.set(loc.x, 0, loc.z + 4);
        npc.userData = { locationId: loc.id };
        scene.add(npc);
        npcs[loc.id] = npc;
      });

      // Wandering NPCs with varied speeds
      WANDERING_NPCS.forEach((data, i) => {
        const angle = (i / WANDERING_NPCS.length) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 10 + Math.random() * 15;
        const npc = createWanderingNPC(data.speed);
        npc.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
        
        // Set speed based on type
        let walkSpeed;
        if (data.speed === 'fast') {
          walkSpeed = 2.5 + Math.random() * 1.5; // Very fast!
        } else if (data.speed === 'slow') {
          walkSpeed = 0.15 + Math.random() * 0.1; // Very slow
        } else {
          walkSpeed = 0.5 + Math.random() * 0.5; // Normal
        }
        
        npc.userData = {
          ...data,
          walkAngle: Math.random() * Math.PI * 2,
          walkSpeed: walkSpeed,
          timer: Math.random() * 5,
          lastQuote: Date.now() - Math.random() * 3000, // Stagger initial quotes
          chatOffset: Math.random() * 4000, // Random offset for chat cooldown
          lastVoice: Date.now() - Math.random() * 10000,
          nextVoiceTime: Date.now() + AMBIENT_VOICE_MIN_DELAY +
            Math.random() * (AMBIENT_VOICE_MAX_DELAY - AMBIENT_VOICE_MIN_DELAY)
        };
        scene.add(npc);
        wanderers.push(npc);
      });

      // Create listeners for Princess Bernie (around speakers area)
      createBernieListeners();

      // Create bees and honey around palace
      createBeesAndHoney();

      // Corgis
      let corgisPlaced = 0;
      let corgiAttempts = 0;
      while (corgisPlaced < 5 && corgiAttempts < 120) {
        corgiAttempts++;
        const angle = Math.random() * Math.PI * 2;
        const radius = 18 + Math.random() * 24;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        if (!isSafeOffPathPlacement(x, z)) continue;

        const corgi = createCorgi();
        corgi.position.set(x, 0, z);
        corgi.rotation.y = Math.random() * Math.PI * 2;
        corgi.userData.baseY = corgi.position.y;
        scene.add(corgi);
        corgis.push(corgi);
        corgisPlaced++;
      }

      // Collectibles
      for (let i = 0; i < 25; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 8 + Math.random() * 35;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        
        // Skip if too close to a building
        const tooClose = collisionBoxes.some(b => 
          x > b.minX - 2 && x < b.maxX + 2 && z > b.minZ - 2 && z < b.maxZ + 2
        );
        if (tooClose) continue;

        const collectible = createCollectible();
        collectible.position.set(x, 0.5, z);
        collectible.userData = { collected: false, floatOffset: Math.random() * Math.PI * 2 };
        scene.add(collectible);
        collectibles.push(collectible);
      }

      // Decorations
      createDecorations();
    }

    function createFountain() {
      // Small collision for fountain
      collisionBoxes.push({ minX: -1.5, maxX: 1.5, minZ: -1.5, maxZ: 1.5 });

      const fountain = new THREE.Group();
      
      // Base
      const baseMat = new THREE.MeshStandardMaterial({ color: 0xf0e6d2 });
      const base = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 0.5, 16), baseMat);
      base.position.y = 0.25;
      base.castShadow = true;
      fountain.add(base);

      // Water
      const water = new THREE.Mesh(
        new THREE.CylinderGeometry(1.2, 1.4, 0.3, 16),
        new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.8 })
      );
      water.position.y = 0.65;
      fountain.add(water);

      // Pillar
      const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 1.5, 8), baseMat);
      pillar.position.y = 1.25;
      pillar.castShadow = true;
      fountain.add(pillar);

      // Crown on top
      const crownMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.2 });
      const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.2, 6), crownMat);
      crownBase.position.y = 2.2;
      fountain.add(crownBase);

      for (let i = 0; i < 5; i++) {
        const a = (i / 5) * Math.PI * 2;
        const point = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.25, 4), crownMat);
        point.position.set(Math.cos(a) * 0.25, 2.4, Math.sin(a) * 0.25);
        fountain.add(point);
      }

      scene.add(fountain);
    }

    function createPlayer() {
      const group = new THREE.Group();
      
      const pinkMat = new THREE.MeshStandardMaterial({ color: 0xffd1e1 });
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffeedd });
      const darkMat = new THREE.MeshStandardMaterial({ color: 0x2c2c2c });
      const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.6, roughness: 0.3 });

      // Body
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), pinkMat);
      body.scale.set(1, 1.2, 0.9);
      body.position.y = 0.6;
      body.castShadow = true;
      group.add(body);

      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.45, 16, 16), skinMat);
      head.position.y = 1.3;
      head.castShadow = true;
      group.add(head);

      // Eyes
      const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.09, 8, 8), darkMat);
      eyeL.position.set(-0.15, 1.35, 0.38);
      group.add(eyeL);
      
      const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.09, 8, 8), darkMat);
      eyeR.position.set(0.15, 1.35, 0.38);
      group.add(eyeR);

      // Blush
      const blushMat = new THREE.MeshStandardMaterial({ color: 0xffb6c1, transparent: true, opacity: 0.6 });
      const blushL = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), blushMat);
      blushL.position.set(-0.3, 1.22, 0.42);
      blushL.rotation.y = 0.3;
      group.add(blushL);
      
      const blushR = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), blushMat);
      blushR.position.set(0.3, 1.22, 0.42);
      blushR.rotation.y = -0.3;
      group.add(blushR);

      // Crown
      const crownBase = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.15, 6), goldMat);
      crownBase.position.y = 1.72;
      group.add(crownBase);

      for (let i = 0; i < 5; i++) {
        const a = (i / 5) * Math.PI * 2;
        const point = new THREE.Mesh(new THREE.ConeGeometry(0.06, 0.22, 4), goldMat);
        point.position.set(Math.cos(a) * 0.2, 1.89, Math.sin(a) * 0.2);
        group.add(point);
      }

      // Legs
      const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.3, 8), pinkMat);
      legL.position.set(-0.2, 0.15, 0);
      legL.castShadow = true;
      group.add(legL);
      
      const legR = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.1, 0.3, 8), pinkMat);
      legR.position.set(0.2, 0.15, 0);
      legR.castShadow = true;
      group.add(legR);

      // Shoes
      const shoeMat = new THREE.MeshStandardMaterial({ color: 0xff69b4 });
      const shoeL = new THREE.Mesh(new THREE.SphereGeometry(0.13, 8, 8), shoeMat);
      shoeL.scale.set(1.2, 0.8, 1.5);
      shoeL.position.set(-0.2, 0.06, 0.05);
      shoeL.castShadow = true;
      group.add(shoeL);
      
      const shoeR = new THREE.Mesh(new THREE.SphereGeometry(0.13, 8, 8), shoeMat);
      shoeR.scale.set(1.2, 0.8, 1.5);
      shoeR.position.set(0.2, 0.06, 0.05);
      shoeR.castShadow = true;
      group.add(shoeR);

      player = group;
      player.position.set(0, 0, 5); // Start outside fountain
      player.userData.baseY = 0;
      player.userData.boostEndTime = 0;
      scene.add(player);
    }

    function createParticleTexture() {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      gradient.addColorStop(0, 'rgba(255,255,255,0.95)');
      gradient.addColorStop(0.4, 'rgba(255,255,255,0.7)');
      gradient.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    function spawnCelebrationBurst() {
      const now = performance.now();
      if (now - lastCelebrationTime < CELEBRATION_COOLDOWN) return;
      lastCelebrationTime = now;

      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(player.quaternion);
      const spawnPos = player.position.clone()
        .add(forward.multiplyScalar(-0.9))
        .add(new THREE.Vector3(0, 0.9, 0));

      const palette = [
        new THREE.Color(0xffd700),
        new THREE.Color(0xffb6c1),
        new THREE.Color(0xff9ad5),
        new THREE.Color(0xaee8ff),
        new THREE.Color(0xfad5a5),
        new THREE.Color(0xe3b6ff)
      ];

      spawnSparkles(spawnPos, palette);
      spawnFireworks(spawnPos, palette);
      spawnConfetti(spawnPos, palette);
      spawnSmoke(spawnPos, palette);
    }

    function createParticleSprite(color, opacity = 1) {
      const material = new THREE.SpriteMaterial({
        map: particleTexture,
        color,
        transparent: true,
        opacity,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });
      const sprite = new THREE.Sprite(material);
      scene.add(sprite);
      return sprite;
    }

    function addParticle({ position, velocity, life, size, color, opacity, rotationSpeed, fade, gravity }) {
      const sprite = createParticleSprite(color, opacity);
      sprite.position.copy(position);
      sprite.scale.set(size, size, size);
      celebrationParticles.push({
        sprite,
        velocity,
        life,
        maxLife: life,
        rotationSpeed,
        fade,
        gravity
      });
    }

    function spawnSparkles(origin, palette) {
      for (let i = 0; i < 20; i++) {
        const color = palette[Math.floor(Math.random() * palette.length)];
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          Math.random() * 2,
          (Math.random() - 0.5) * 2
        );
        addParticle({
          position: origin.clone().add(new THREE.Vector3((Math.random() - 0.5) * 0.4, (Math.random() - 0.2) * 0.4, (Math.random() - 0.5) * 0.4)),
          velocity,
          life: 0.6 + Math.random() * 0.4,
          size: 0.25 + Math.random() * 0.2,
          color,
          opacity: 0.9,
          rotationSpeed: (Math.random() - 0.5) * 6,
          fade: 1.2,
          gravity: -2
        });
      }
    }

    function spawnFireworks(origin, palette) {
      for (let i = 0; i < 12; i++) {
        const color = palette[Math.floor(Math.random() * palette.length)];
        const angle = (i / 12) * Math.PI * 2;
        const velocity = new THREE.Vector3(Math.cos(angle) * 2, 2.5 + Math.random(), Math.sin(angle) * 2);
        addParticle({
          position: origin.clone(),
          velocity,
          life: 0.9 + Math.random() * 0.4,
          size: 0.35 + Math.random() * 0.25,
          color,
          opacity: 0.95,
          rotationSpeed: (Math.random() - 0.5) * 3,
          fade: 1.4,
          gravity: -3
        });
      }
    }

    function spawnConfetti(origin, palette) {
      for (let i = 0; i < 18; i++) {
        const color = palette[Math.floor(Math.random() * palette.length)];
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 1.5,
          1.2 + Math.random() * 0.8,
          (Math.random() - 0.5) * 1.5
        );
        addParticle({
          position: origin.clone().add(new THREE.Vector3((Math.random() - 0.5) * 0.6, Math.random() * 0.6, (Math.random() - 0.5) * 0.6)),
          velocity,
          life: 1.2 + Math.random() * 0.6,
          size: 0.3 + Math.random() * 0.2,
          color,
          opacity: 0.85,
          rotationSpeed: (Math.random() - 0.5) * 8,
          fade: 0.9,
          gravity: -1.2
        });
      }
    }

    function spawnSmoke(origin, palette) {
      for (let i = 0; i < 8; i++) {
        const color = palette[Math.floor(Math.random() * palette.length)].clone().lerp(new THREE.Color(0xffffff), 0.4);
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.6,
          0.6 + Math.random() * 0.6,
          (Math.random() - 0.5) * 0.6
        );
        addParticle({
          position: origin.clone().add(new THREE.Vector3((Math.random() - 0.5) * 0.4, Math.random() * 0.5, (Math.random() - 0.5) * 0.4)),
          velocity,
          life: 1.3 + Math.random() * 0.6,
          size: 0.6 + Math.random() * 0.4,
          color,
          opacity: 0.5,
          rotationSpeed: (Math.random() - 0.5) * 2,
          fade: 0.7,
          gravity: -0.6
        });
      }
    }

    function updateCelebrationParticles(delta) {
      for (let i = celebrationParticles.length - 1; i >= 0; i--) {
        const particle = celebrationParticles[i];
        particle.velocity.y += particle.gravity * delta;
        particle.sprite.position.addScaledVector(particle.velocity, delta);
        particle.sprite.material.opacity = Math.max(0, particle.sprite.material.opacity - delta * particle.fade);
        particle.sprite.material.rotation += particle.rotationSpeed * delta;
        particle.life -= delta;
        if (particle.life <= 0) {
          scene.remove(particle.sprite);
          particle.sprite.material.dispose();
          celebrationParticles.splice(i, 1);
        }
      }
    }

    function getPlayerSpeed(now) {
      if (now < player.userData.boostEndTime) {
        return BOOST_PLAYER_SPEED;
      }
      return BASE_PLAYER_SPEED;
    }

    function createBuilding(color, type) {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color });
      const roofColor = new THREE.Color(color).multiplyScalar(0.8).getHex();
      const roofMat = new THREE.MeshStandardMaterial({ color: roofColor });
      const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

      if (type === 'palace') {
        const base = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 3), mat);
        base.position.y = 1.5;
        base.castShadow = true;
        group.add(base);

        const roof = new THREE.Mesh(new THREE.ConeGeometry(3.2, 1.5, 4), roofMat);
        roof.position.y = 3.75;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);

        [-1.8, 1.8].forEach(x => {
          const tower = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.7, 4.5, 8), mat);
          tower.position.set(x, 2.25, -1.3);
          tower.castShadow = true;
          group.add(tower);

          const towerRoof = new THREE.Mesh(new THREE.ConeGeometry(0.85, 1.3, 8), roofMat);
          towerRoof.position.set(x, 5.15, -1.3);
          towerRoof.castShadow = true;
          group.add(towerRoof);
        });
      } else if (type === 'teashop') {
        const base = new THREE.Mesh(new THREE.BoxGeometry(3.2, 2.2, 2.8), mat);
        base.position.y = 1.1;
        base.castShadow = true;
        group.add(base);

        const roof = new THREE.Mesh(new THREE.ConeGeometry(2.8, 1.2, 4), roofMat);
        roof.position.y = 2.8;
        roof.rotation.y = Math.PI / 4;
        roof.castShadow = true;
        group.add(roof);

        const teapot = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 12), whiteMat);
        teapot.position.y = 3.7;
        group.add(teapot);
      } else if (type === 'speakers') {
        const stage = new THREE.Mesh(new THREE.CylinderGeometry(2.3, 2.5, 0.35, 8), whiteMat);
        stage.position.y = 0.175;
        stage.castShadow = true;
        group.add(stage);

        for (let i = 0; i < 6; i++) {
          const a = (i / 6) * Math.PI * 2;
          const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.14, 0.18, 2.8, 8), whiteMat);
          pillar.position.set(Math.cos(a) * 1.9, 1.75, Math.sin(a) * 1.9);
          pillar.castShadow = true;
          group.add(pillar);
        }

        const dome = new THREE.Mesh(new THREE.SphereGeometry(2.5, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), mat);
        dome.position.y = 3.15;
        dome.castShadow = true;
        group.add(dome);
      } else if (type === 'guests') {
        const tower = new THREE.Mesh(new THREE.CylinderGeometry(1.6, 1.9, 4, 8), mat);
        tower.position.y = 2;
        tower.castShadow = true;
        group.add(tower);

        const roof = new THREE.Mesh(new THREE.ConeGeometry(2, 1.6, 8), roofMat);
        roof.position.y = 5.4;
        roof.castShadow = true;
        group.add(roof);
      } else if (type === 'feast') {
        const base = new THREE.Mesh(new THREE.BoxGeometry(3.8, 2.2, 2.8), mat);
        base.position.y = 1.1;
        base.castShadow = true;
        group.add(base);

        const roofShape = new THREE.Shape();
        roofShape.moveTo(-2.3, 0);
        roofShape.lineTo(0, 1.4);
        roofShape.lineTo(2.3, 0);
        roofShape.closePath();
        const roofGeo = new THREE.ExtrudeGeometry(roofShape, { depth: 3.2, bevelEnabled: false });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.set(0, 2.2, -1.6);
        roof.castShadow = true;
        group.add(roof);
      }

      return group;
    }

    function createNPC() {
      const group = new THREE.Group();
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffeedd });
      const robeMat = new THREE.MeshStandardMaterial({ color: 0xd4b8ff });

      // Body
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 0.6, 16), skinMat);
      body.position.y = 0.9;
      body.castShadow = true;
      group.add(body);

      // Torso top
      const torsoTop = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), skinMat);
      torsoTop.position.y = 1.2;
      group.add(torsoTop);

      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.38, 16, 16), skinMat);
      head.position.y = 1.75;
      head.castShadow = true;
      group.add(head);

      // Indicator
      const indicator = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.4, transparent: true, opacity: 0.9 })
      );
      indicator.position.y = 2.5;
      indicator.userData.isIndicator = true;
      group.add(indicator);

      // Robe
      const robe = new THREE.Mesh(new THREE.ConeGeometry(0.55, 1.1, 8, 1, true), robeMat);
      robe.position.y = 0.55;
      robe.rotation.x = Math.PI;
      robe.castShadow = true;
      group.add(robe);

      return group;
    }

    function createWanderingNPC(speedType) {
      const group = new THREE.Group();
      
      // Different colors based on speed type
      let bodyColors;
      if (speedType === 'fast') {
        bodyColors = [0xff6b6b, 0xff8c42, 0xffdd59, 0xff6b9d]; // Energetic warm colors
      } else if (speedType === 'slow') {
        bodyColors = [0xc9b8a8, 0xa8a8c9, 0xb8c9a8, 0xd4c4b0]; // Muted elderly colors
      } else {
        bodyColors = [0xffc0cb, 0xadd8e6, 0x98fb98, 0xdda0dd, 0xf0e68c, 0xffa07a];
      }
      
      const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColors[Math.floor(Math.random() * bodyColors.length)] });
      const skinMat = new THREE.MeshStandardMaterial({ color: 0xffeedd });

      // Body - slightly hunched for elderly
      const body = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 12), bodyMat);
      body.scale.set(1, speedType === 'slow' ? 1.1 : 1.3, 1);
      body.position.y = 0.55;
      body.castShadow = true;
      group.add(body);

      // Head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 12, 12), skinMat);
      head.position.y = speedType === 'slow' ? 1.0 : 1.1;
      head.castShadow = true;
      group.add(head);

      // Legs
      const legL = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, 0.2, 6), bodyMat);
      legL.position.set(-0.15, 0.1, 0);
      group.add(legL);

      const legR = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, 0.2, 6), bodyMat);
      legR.position.set(0.15, 0.1, 0);
      group.add(legR);

      // Add accessories based on type
      if (speedType === 'fast') {
        // Sweat drops or motion lines effect (small spheres)
        const sweatMat = new THREE.MeshStandardMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.7 });
        const sweat = new THREE.Mesh(new THREE.SphereGeometry(0.05, 6, 6), sweatMat);
        sweat.position.set(-0.35, 1.15, 0);
        group.add(sweat);
      } else if (speedType === 'slow') {
        // Walking cane
        const caneMat = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const cane = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.8, 6), caneMat);
        cane.position.set(0.35, 0.4, 0);
        cane.rotation.z = 0.2;
        group.add(cane);
        
        // Glasses
        const glassesMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const glasses = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.015, 8, 16), glassesMat);
        glasses.position.set(0, 1.05, 0.28);
        glasses.rotation.x = Math.PI / 2;
        group.add(glasses);
      }

      return group;
    }

    function createCorgi() {
      if (!corgiFurMaterial) {
        corgiFurMaterial = new THREE.MeshStandardMaterial({ color: 0xd49a6a });
      }
      if (!corgiAccentMaterial) {
        corgiAccentMaterial = new THREE.MeshStandardMaterial({ color: 0x8b5a3c });
      }

      const corgi = new THREE.Group();

      const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 0.7), corgiFurMaterial);
      body.position.y = 0.55;
      body.castShadow = true;
      corgi.add(body);

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), corgiFurMaterial);
      head.position.set(0.9, 0.85, 0);
      head.castShadow = true;
      corgi.add(head);

      const earL = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), corgiAccentMaterial);
      earL.position.set(0.82, 1.05, 0.18);
      corgi.add(earL);

      const earR = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), corgiAccentMaterial);
      earR.position.set(0.82, 1.05, -0.18);
      corgi.add(earR);

      const tail = new THREE.Mesh(new THREE.SphereGeometry(0.14, 12, 12), corgiAccentMaterial);
      tail.position.set(-0.75, 0.72, 0);
      corgi.add(tail);

      const legGeo = new THREE.BoxGeometry(0.2, 0.35, 0.2);
      const legs = [];
      const legPositions = [
        { x: 0.5, z: 0.25, dir: 1 },
        { x: 0.5, z: -0.25, dir: -1 },
        { x: -0.35, z: 0.25, dir: -1 },
        { x: -0.35, z: -0.25, dir: 1 }
      ];

      legPositions.forEach(({ x, z, dir }) => {
        const leg = new THREE.Mesh(legGeo, corgiFurMaterial);
        leg.position.set(x, 0.2, z);
        leg.userData.swingDir = dir;
        corgi.add(leg);
        legs.push(leg);
      });

      corgi.userData = {
        baseY: 0,
        bobOffset: Math.random() * Math.PI * 2,
        legs
      };

      return corgi;
    }

    function createCollectible() {
      const group = new THREE.Group();
      const colors = [0xff6b6b, 0xffd93d, 0x6bcb77, 0x4d96ff, 0xff6bd6, 0xffd700];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.25 });

      const types = ['candy', 'crown', 'gem'];
      const type = types[Math.floor(Math.random() * types.length)];

      if (type === 'candy') {
        const candy = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), mat);
        candy.scale.set(1.5, 1, 1);
        group.add(candy);
      } else if (type === 'crown') {
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.15, 6), mat);
        group.add(base);
        for (let i = 0; i < 5; i++) {
          const a = (i / 5) * Math.PI * 2;
          const point = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.15, 4), mat);
          point.position.set(Math.cos(a) * 0.15, 0.12, Math.sin(a) * 0.15);
          group.add(point);
        }
      } else {
        const gem = new THREE.Mesh(new THREE.OctahedronGeometry(0.25), mat);
        group.add(gem);
      }

      return group;
    }

    function createBeesAndHoney() {
      // Get palace position
      const palacePos = LOCATIONS.find(l => l.id === 'palace');
      
      // Create honey puddles around palace
      const honeyMat = new THREE.MeshStandardMaterial({ 
        color: 0xffc61a, 
        roughness: 0.2, 
        metalness: 0.3,
        transparent: true,
        opacity: 0.85
      });
      
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + Math.random() * 0.5;
        const radius = 5 + Math.random() * 4;
        const honey = new THREE.Mesh(
          new THREE.CircleGeometry(0.4 + Math.random() * 0.4, 12),
          honeyMat
        );
        honey.rotation.x = -Math.PI / 2;
        honey.position.set(
          palacePos.x + Math.cos(angle) * radius,
          0.04,
          palacePos.z + Math.sin(angle) * radius
        );
        scene.add(honey);
      }
      
      // Create bees
      const beeMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
      const stripeMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
      const wingMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });
      
      for (let i = 0; i < 6; i++) {
        const bee = new THREE.Group();
        
        // Body
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.12, 8, 8), beeMat);
        body.scale.set(1.5, 1, 1);
        bee.add(body);
        
        // Stripes
        for (let s = 0; s < 2; s++) {
          const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.11, 0.025, 6, 12), stripeMat);
          stripe.position.x = -0.05 + s * 0.1;
          stripe.rotation.y = Math.PI / 2;
          bee.add(stripe);
        }
        
        // Wings
        const wingGeo = new THREE.SphereGeometry(0.08, 6, 6);
        wingGeo.scale(1, 0.3, 1.5);
        const wingL = new THREE.Mesh(wingGeo, wingMat);
        wingL.position.set(0, 0.08, 0.1);
        bee.add(wingL);
        const wingR = new THREE.Mesh(wingGeo, wingMat);
        wingR.position.set(0, 0.08, -0.1);
        bee.add(wingR);
        
        // Position around palace
        const angle = Math.random() * Math.PI * 2;
        const radius = 2 + Math.random() * 4;
        bee.position.set(
          palacePos.x + Math.cos(angle) * radius,
          2 + Math.random() * 2,
          palacePos.z + Math.sin(angle) * radius
        );
        bee.userData = {
          baseY: bee.position.y,
          angle: angle,
          radius: radius,
          speed: 1 + Math.random() * 2,
          bobSpeed: 3 + Math.random() * 2,
          palaceX: palacePos.x,
          palaceZ: palacePos.z
        };
        
        scene.add(bee);
        bees.push(bee);
      }
    }

    function createBernieListeners() {
      // Get speakers position (Princess Bernie's location)
      const speakersPos = LOCATIONS.find(l => l.id === 'speakers');
      
      const listenerData = [
        { name: 'Eager Earl', quotes: ["Ooh, tell us more!", "This is SO inspiring!", "I'm taking notes!", "*claps enthusiastically*", "WOOO! Go Princess Bernie!"] },
        { name: 'Curious Carol', quotes: ["Fascinating!", "Wait, can you repeat that?", "My mind is BLOWN!", "I need to write this down!", "This changes EVERYTHING!"] },
        { name: 'Listener Larry', quotes: ["Mmhmm, mmhmm...", "*nods wisely*", "Profound!", "I totally get it now!", "This is better than my nap!"] },
        { name: 'Attentive Annie', quotes: ["*leans in*", "Go on...", "Yes, YES!", "Preach it!", "I'm learning so much!"] },
        { name: 'Nodding Ned', quotes: ["*nods*", "*nods faster*", "*nods so hard head falls off*", "Absolutely!", "Couldn't agree more!"] }
      ];
      
      // Create 5 listener NPCs that will gather around Bernie
      for (let i = 0; i < 5; i++) {
        const listener = createWanderingNPC('normal');
        
        // Start them scattered nearby
        const startAngle = Math.random() * Math.PI * 2;
        const startRadius = 15 + Math.random() * 10;
        listener.position.set(
          speakersPos.x + Math.cos(startAngle) * startRadius,
          0,
          speakersPos.z + Math.sin(startAngle) * startRadius
        );
        
        // Target position around Bernie (semi-circle in front)
        const targetAngle = (Math.PI * 0.3) + (i / 5) * (Math.PI * 0.4); // Arc in front
        const targetRadius = 5 + (i % 2) * 1.5;
        
        listener.userData = {
          ...listenerData[i],
          role: 'Audience Member',
          isListener: true,
          targetX: speakersPos.x + Math.cos(targetAngle) * targetRadius,
          targetZ: speakersPos.z + Math.sin(targetAngle) * targetRadius,
          wanderAngle: Math.random() * Math.PI * 2,
          state: 'wandering', // wandering, gathering, listening, leaving
          speed: 0.8,
          lastQuote: Date.now() - Math.random() * 3000,
          chatOffset: Math.random() * 4000,
          nextVoiceTime: Date.now() + AMBIENT_VOICE_MIN_DELAY +
            Math.random() * (AMBIENT_VOICE_MAX_DELAY - AMBIENT_VOICE_MIN_DELAY)
        };
        
        scene.add(listener);
        bernieListeners.push(listener);
      }
    }

    function createDecorations() {
      // Flowers
      const flowerColors = [0xff69b4, 0xffd700, 0xff6347, 0x9370db, 0x00ced1];
      for (let i = 0; i < 80; i++) {
        const flower = createFlower(flowerColors[Math.floor(Math.random() * flowerColors.length)]);
        flower.position.set((Math.random() - 0.5) * 90, 0, (Math.random() - 0.5) * 90);
        flower.scale.setScalar(0.4 + Math.random() * 0.5);
        scene.add(flower);
      }

      // Trees
      const treePositions = [
        { x: 10, z: -10 }, { x: -10, z: -10 }, { x: 18, z: 5 },
        { x: -18, z: 5 }, { x: 0, z: 22 }, { x: 15, z: 18 }, { x: -15, z: 18 }
      ];
      treePositions.forEach(pos => {
        const tree = createTree();
        tree.position.set(pos.x, 0, pos.z);
        tree.scale.setScalar(0.7 + Math.random() * 0.5);
        scene.add(tree);
      });

      // Mushrooms
      for (let i = 0; i < 30; i++) {
        const mushroom = createMushroom();
        mushroom.position.set((Math.random() - 0.5) * 80, 0, (Math.random() - 0.5) * 80);
        mushroom.scale.setScalar(0.25 + Math.random() * 0.35);
        scene.add(mushroom);
      }

      // Clouds
      for (let i = 0; i < 12; i++) {
        const cloud = createCloud();
        cloud.position.set((Math.random() - 0.5) * 100, 18 + Math.random() * 12, (Math.random() - 0.5) * 100);
        cloud.userData.speed = 0.015 + Math.random() * 0.025;
        cloud.scale.setScalar(0.8 + Math.random() * 0.6);
        scene.add(cloud);
        clouds.push(cloud);
      }

      // Royal props placed beyond paths
      createRoyalProps();
    }

    function createRoyalProps() {
      const placements = [
        { create: createHugeRedChair, x: 28, z: -30, scale: 1.2 },
        { create: createCakeWithCherry, x: -32, z: -24, scale: 1.1 },
        { create: createMilkTart, x: 34, z: 22, scale: 1 },
        { create: createIceCreamGlass, x: -26, z: 30, scale: 1.05 },
        { create: createPinkSodaGlass, x: 22, z: 32, scale: 1 },
        { create: createGoldenTeapot, x: -36, z: 12, scale: 1 },
        { create: createMacaronTower, x: 12, z: -36, scale: 1.1 },
        { create: createCrownCushion, x: -18, z: -34, scale: 1 }
      ];

      placements.forEach(({ create, x, z, scale }) => {
        if (!isSafeOffPathPlacement(x, z)) return;
        const prop = create();
        prop.position.set(x, 0, z);
        prop.scale.setScalar(scale);
        scene.add(prop);
      });
    }

    function isSafeOffPathPlacement(x, z) {
      const radius = Math.hypot(x, z);
      if (radius < 16 || radius > 46) {
        return false;
      }
      if (isNearPath(x, z, 2.5)) {
        return false;
      }
      if (!isClearOfBuildings(x, z, 3)) {
        return false;
      }
      return true;
    }

    function isNearPath(x, z, buffer = 1.5) {
      const halfWidth = PATH_CONFIG.width / 2 + buffer;
      for (let i = 0; i < PATH_CONFIG.count; i++) {
        const angle = PATH_CONFIG.angleStep * i;
        const axisX = Math.sin(angle);
        const axisZ = Math.cos(angle);
        const projection = x * axisX + z * axisZ;
        if (projection < -buffer || projection > PATH_CONFIG.length + buffer) {
          continue;
        }
        const perpendicular = Math.abs(-axisZ * x + axisX * z);
        if (perpendicular <= halfWidth) {
          return true;
        }
      }
      return false;
    }

    function isClearOfBuildings(x, z, buffer = 2) {
      return !collisionBoxes.some(b =>
        x > b.minX - buffer && x < b.maxX + buffer && z > b.minZ - buffer && z < b.maxZ + buffer
      );
    }

    function createFlower(color) {
      const group = new THREE.Group();
      
      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.04, 0.5, 6),
        new THREE.MeshStandardMaterial({ color: 0x228b22 })
      );
      stem.position.y = 0.25;
      group.add(stem);

      const petalGeo = new THREE.SphereGeometry(0.14, 8, 8);
      petalGeo.scale(1, 0.5, 1);
      const petalMat = new THREE.MeshStandardMaterial({ color });
      
      for (let i = 0; i < 5; i++) {
        const a = (i / 5) * Math.PI * 2;
        const petal = new THREE.Mesh(petalGeo, petalMat);
        petal.position.set(Math.cos(a) * 0.12, 0.55, Math.sin(a) * 0.12);
        group.add(petal);
      }

      const center = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0xffd700 })
      );
      center.position.y = 0.55;
      group.add(center);

      return group;
    }

    function createTree() {
      const group = new THREE.Group();
      
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.45, 2.5, 8),
        new THREE.MeshStandardMaterial({ color: 0x8b4513 })
      );
      trunk.position.y = 1.25;
      trunk.castShadow = true;
      group.add(trunk);

      const foliageMat = new THREE.MeshStandardMaterial({ color: 0x90ee90 });
      [{ y: 3, r: 1.4 }, { y: 4, r: 1.1 }, { y: 4.8, r: 0.7 }].forEach(f => {
        const foliage = new THREE.Mesh(new THREE.SphereGeometry(f.r, 12, 12), foliageMat);
        foliage.position.y = f.y;
        foliage.castShadow = true;
        group.add(foliage);
      });

      return group;
    }

    function createMushroom() {
      const group = new THREE.Group();
      
      const stem = new THREE.Mesh(
        new THREE.CylinderGeometry(0.18, 0.25, 0.5, 8),
        new THREE.MeshStandardMaterial({ color: 0xfff8dc })
      );
      stem.position.y = 0.25;
      group.add(stem);

      const capColors = [0xff6b6b, 0xff69b4, 0xffa07a, 0x9370db];
      const cap = new THREE.Mesh(
        new THREE.SphereGeometry(0.4, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshStandardMaterial({ color: capColors[Math.floor(Math.random() * capColors.length)] })
      );
      cap.position.y = 0.5;
      group.add(cap);

      return group;
    }

    function createCloud() {
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.92 });
      
      [{ x: 0, r: 2 }, { x: 1.6, r: 1.4 }, { x: -1.5, r: 1.5 }, { x: 0.8, r: 1.1 }, { x: -0.8, r: 1.2 }].forEach(p => {
        const puff = new THREE.Mesh(new THREE.SphereGeometry(p.r, 12, 12), mat);
        puff.position.set(p.x, Math.random() * 0.5, Math.random() * 0.5 - 0.25);
        group.add(puff);
      });

      return group;
    }

    function createHugeRedChair() {
      const group = new THREE.Group();
      const chairMat = new THREE.MeshStandardMaterial({ color: 0xe63946, roughness: 0.6 });
      const cushionMat = new THREE.MeshStandardMaterial({ color: 0xffa3b1, roughness: 0.7 });
      const woodMat = new THREE.MeshStandardMaterial({ color: 0x8b3a3a, roughness: 0.8 });

      const seat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 2.5), chairMat);
      seat.position.y = 0.8;
      seat.castShadow = true;
      group.add(seat);

      const back = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 0.5), chairMat);
      back.position.set(0, 2, -1);
      back.castShadow = true;
      group.add(back);

      const cushion = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.35, 1.9), cushionMat);
      cushion.position.y = 1.1;
      group.add(cushion);

      [-1.2, 1.2].forEach(x => {
        [-0.9, 0.9].forEach(z => {
          const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.16, 0.8, 8), woodMat);
          leg.position.set(x, 0.4, z);
          leg.castShadow = true;
          group.add(leg);
        });
      });

      return group;
    }

    function createCakeWithCherry() {
      const group = new THREE.Group();
      const cakeMat = new THREE.MeshStandardMaterial({ color: 0xfff0d6, roughness: 0.7 });
      const frostingMat = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 0.6 });
      const cherryMat = new THREE.MeshStandardMaterial({ color: 0xd62828, roughness: 0.4 });
      const plateMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });

      const plate = new THREE.Mesh(new THREE.CylinderGeometry(1.4, 1.6, 0.15, 16), plateMat);
      plate.position.y = 0.1;
      group.add(plate);

      const cake = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.2, 0.8, 20), cakeMat);
      cake.position.y = 0.6;
      cake.castShadow = true;
      group.add(cake);

      const frosting = new THREE.Mesh(new THREE.CylinderGeometry(1.15, 1.25, 0.25, 20), frostingMat);
      frosting.position.y = 1.05;
      group.add(frosting);

      const cherry = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 16), cherryMat);
      cherry.position.set(0.2, 1.3, 0);
      group.add(cherry);

      const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.2, 6), new THREE.MeshStandardMaterial({ color: 0x2e8b57 }));
      stem.position.set(0.2, 1.45, 0);
      stem.rotation.z = 0.5;
      group.add(stem);

      return group;
    }

    function createMilkTart() {
      const group = new THREE.Group();
      const crustMat = new THREE.MeshStandardMaterial({ color: 0xf4c27a, roughness: 0.8 });
      const fillingMat = new THREE.MeshStandardMaterial({ color: 0xfff3c1, roughness: 0.6 });
      const dustMat = new THREE.MeshStandardMaterial({ color: 0xcfa670, roughness: 0.9 });

      const crust = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.1, 0.4, 16), crustMat);
      crust.position.y = 0.25;
      crust.castShadow = true;
      group.add(crust);

      const filling = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.95, 0.25, 16), fillingMat);
      filling.position.y = 0.55;
      group.add(filling);

      const dust = new THREE.Mesh(new THREE.CircleGeometry(0.75, 16), dustMat);
      dust.rotation.x = -Math.PI / 2;
      dust.position.y = 0.7;
      group.add(dust);

      return group;
    }

    function createIceCreamGlass() {
      const group = new THREE.Group();
      const glassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.55 });
      const stemMat = new THREE.MeshStandardMaterial({ color: 0xd9f7ff, roughness: 0.3, metalness: 0.2 });
      const scoopColors = [0xffd1dc, 0xfde2a7, 0xc1e1c1];

      const bowl = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.6, 1.1, 16, 1, true), glassMat);
      bowl.position.y = 1.1;
      group.add(bowl);

      const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.7, 8), stemMat);
      stem.position.y = 0.35;
      group.add(stem);

      const base = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 0.15, 12), stemMat);
      base.position.y = 0.05;
      group.add(base);

      scoopColors.forEach((color, i) => {
        const scoop = new THREE.Mesh(new THREE.SphereGeometry(0.45, 14, 14), new THREE.MeshStandardMaterial({ color }));
        scoop.position.set((i - 1) * 0.35, 1.5 + i * 0.2, 0);
        scoop.castShadow = true;
        group.add(scoop);
      });

      return group;
    }

    function createPinkSodaGlass() {
      const group = new THREE.Group();
      const glassMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
      const sodaMat = new THREE.MeshStandardMaterial({ color: 0xff8fb1, transparent: true, opacity: 0.7 });
      const strawMat = new THREE.MeshStandardMaterial({ color: 0xff5c8a, roughness: 0.4 });

      const glass = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.6, 16), glassMat);
      glass.position.y = 0.9;
      group.add(glass);

      const soda = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.55, 1.2, 16), sodaMat);
      soda.position.y = 0.75;
      group.add(soda);

      const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.8, 8), strawMat);
      straw.position.set(0.15, 1.4, 0);
      straw.rotation.z = 0.2;
      group.add(straw);

      return group;
    }

    function createGoldenTeapot() {
      const group = new THREE.Group();
      const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd36e, metalness: 0.7, roughness: 0.3 });

      const body = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), goldMat);
      body.scale.set(1.2, 1, 1);
      body.position.y = 0.9;
      body.castShadow = true;
      group.add(body);

      const lid = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.45, 0.2, 12), goldMat);
      lid.position.y = 1.5;
      group.add(lid);

      const spout = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.18, 0.8, 8), goldMat);
      spout.position.set(1, 1, 0.3);
      spout.rotation.z = -0.7;
      group.add(spout);

      const handle = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.08, 8, 16), goldMat);
      handle.position.set(-1, 1, 0);
      handle.rotation.y = Math.PI / 2;
      group.add(handle);

      return group;
    }

    function createMacaronTower() {
      const group = new THREE.Group();
      const colors = [0xffc1cc, 0xffe0a3, 0xc7e9f1, 0xd6c1f7];
      colors.forEach((color, i) => {
        const macaron = new THREE.Mesh(new THREE.CylinderGeometry(0.6 - i * 0.08, 0.6 - i * 0.08, 0.25, 16), new THREE.MeshStandardMaterial({ color }));
        macaron.position.y = 0.2 + i * 0.3;
        macaron.castShadow = true;
        group.add(macaron);
      });
      return group;
    }

    function createCrownCushion() {
      const group = new THREE.Group();
      const cushionMat = new THREE.MeshStandardMaterial({ color: 0xff7ab6, roughness: 0.7 });
      const trimMat = new THREE.MeshStandardMaterial({ color: 0xfff4d1, roughness: 0.6 });

      const base = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.4, 1.2), cushionMat);
      base.position.y = 0.25;
      base.castShadow = true;
      group.add(base);

      const trim = new THREE.Mesh(new THREE.TorusGeometry(0.65, 0.08, 8, 16), trimMat);
      trim.position.y = 0.5;
      trim.rotation.x = Math.PI / 2;
      group.add(trim);

      const jewel = new THREE.Mesh(new THREE.SphereGeometry(0.12, 12, 12), new THREE.MeshStandardMaterial({ color: 0x7dd3fc }));
      jewel.position.set(0, 0.6, 0.35);
      group.add(jewel);

      return group;
    }

    function checkCollision(x, z) {
      // Check building collisions
      for (const box of collisionBoxes) {
        if (x > box.minX && x < box.maxX && z > box.minZ && z < box.maxZ) {
          return true;
        }
      }
      // Check world boundary
      if (Math.sqrt(x * x + z * z) > 48) {
        return true;
      }
      return false;
    }

    function startAdventure() {
      document.getElementById('intro-modal').classList.remove('visible');
      gameState.dialogOpen = false;
      gameState.started = true;
      if (!musicState.initialized) {
        musicState.initialized = true;
        playCurrentTrack();
      }
    }

    function updateKeyboardVector() {
      keyboardInput.x = (keyboardState.right ? 1 : 0) + (keyboardState.left ? -1 : 0);
      keyboardInput.y = (keyboardState.down ? 1 : 0) + (keyboardState.up ? -1 : 0);
      const length = Math.hypot(keyboardInput.x, keyboardInput.y);
      if (length > 1) {
        keyboardInput.x /= length;
        keyboardInput.y /= length;
      }
    }

    function setDesktopMode(enabled) {
      desktopModeEnabled = enabled;
      const joystickContainer = document.getElementById('joystick-container');
      const keyboardHints = document.getElementById('keyboard-hints');
      joystickContainer.classList.toggle('is-hidden', enabled);
      keyboardHints.classList.toggle('visible', enabled);
      if (!enabled) {
        keyboardState.up = false;
        keyboardState.down = false;
        keyboardState.left = false;
        keyboardState.right = false;
        updateKeyboardVector();
      }
    }

    function setupControls() {
      const container = document.getElementById('joystick-container');
      const thumb = document.getElementById('joystick-thumb');
      const baseRadius = 55;
      const maxDistance = 32;
      let active = false;
      let centerX = 0;
      let centerY = 0;
      const desktopSection = document.getElementById('desktop-mode-section');
      const desktopToggle = document.getElementById('desktop-mode-toggle');
      const isLikelyDesktop = window.matchMedia('(hover: hover) and (pointer: fine)').matches
        || /Windows|Macintosh|Linux/.test(navigator.userAgent);

      if (isLikelyDesktop) {
        desktopSection.classList.add('visible');
      } else {
        desktopSection.classList.remove('visible');
      }
      setDesktopMode(false);
      desktopToggle.checked = false;
      desktopToggle.addEventListener('change', (e) => {
        setDesktopMode(e.target.checked);
      });

      function start(e) {
        if (gameState.dialogOpen || !gameState.started) return;
        e.preventDefault();
        active = true;
        const rect = container.getBoundingClientRect();
        centerX = rect.left + baseRadius;
        centerY = rect.top + baseRadius;
      }

      function move(e) {
        if (!active) return;
        e.preventDefault();
        const touch = e.touches ? e.touches[0] : e;
        let dx = touch.clientX - centerX;
        let dy = touch.clientY - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > maxDistance) {
          dx = (dx / distance) * maxDistance;
          dy = (dy / distance) * maxDistance;
        }
        
        thumb.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        joystickInput.x = dx / maxDistance;
        joystickInput.y = dy / maxDistance;
      }

      function end() {
        active = false;
        thumb.style.transform = 'translate(-50%, -50%)';
        joystickInput.x = 0;
        joystickInput.y = 0;
      }

      container.addEventListener('touchstart', start, { passive: false });
      container.addEventListener('touchmove', move, { passive: false });
      container.addEventListener('touchend', end);
      container.addEventListener('touchcancel', end);
      container.addEventListener('mousedown', start);
      document.addEventListener('mousemove', move);
      document.addEventListener('mouseup', end);

      document.addEventListener('keydown', (e) => {
        if (!desktopModeEnabled) return;
        const key = e.key.toLowerCase();
        if (['w', 'a', 's', 'd'].includes(key)) {
          e.preventDefault();
        }
        switch (key) {
          case 'w':
            keyboardState.up = true;
            break;
          case 's':
            keyboardState.down = true;
            break;
          case 'a':
            keyboardState.left = true;
            break;
          case 'd':
            keyboardState.right = true;
            break;
          case 'p':
            if (!e.repeat && !gameState.dialogOpen && gameState.started && (gameState.nearNPC || gameState.nearWanderer)) {
              handleAction();
            }
            break;
          default:
            break;
        }
        updateKeyboardVector();
      });

      document.addEventListener('keyup', (e) => {
        if (!desktopModeEnabled) return;
        const key = e.key.toLowerCase();
        switch (key) {
          case 'w':
            keyboardState.up = false;
            break;
          case 's':
            keyboardState.down = false;
            break;
          case 'a':
            keyboardState.left = false;
            break;
          case 'd':
            keyboardState.right = false;
            break;
          default:
            break;
        }
        updateKeyboardVector();
      });

      // Action button
      const actionBtn = document.getElementById('action-btn');
      actionBtn.addEventListener('pointerup', (e) => {
        e.preventDefault();
        handleAction();
      });
      actionBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
          e.preventDefault();
          handleAction();
        }
      });

      // Dialog close
      document.getElementById('dialog-close').addEventListener('click', closeDialog);
      document.getElementById('dialog-overlay').addEventListener('click', (e) => {
        if (e.target.id === 'dialog-overlay') closeDialog();
      });

      // Completion modal
      document.getElementById('completion-close').addEventListener('click', closeCompletion);
      document.getElementById('continue-btn').addEventListener('click', closeCompletion);

      // Music controls
      document.getElementById('music-toggle').addEventListener('click', () => {
        toggleMusicMute();
        if (!musicState.initialized) {
          musicState.initialized = true;
          playCurrentTrack();
        }
      });
      document.getElementById('music-next').addEventListener('click', () => {
        musicState.initialized = true;
        playNextTrack();
      });

      // Start button
      document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('splash-screen').classList.add('hidden');
        // Also hide map overlay and reset map zoom state
        document.getElementById('map-overlay').classList.remove('visible');
        document.getElementById('splash-map').classList.remove('zoomed');
        document.getElementById('loading-screen').classList.remove('hidden');
        setTimeout(() => {
          document.getElementById('loading-screen').classList.add('hidden');
          document.getElementById('intro-modal').classList.add('visible');
          gameState.dialogOpen = true;
        }, 2000);
      });

      document.getElementById('intro-start').addEventListener('click', () => {
        startAdventure();
      });

      document.getElementById('intro-modal').addEventListener('click', (e) => {
        if (e.target.id === 'intro-modal') {
          startAdventure();
        }
      });

      document.getElementById('sweet-dismiss').addEventListener('click', dismissSweetIntro);

      // Map zoom functionality
      const splashMap = document.getElementById('splash-map');
      const mapOverlay = document.getElementById('map-overlay');
      
      splashMap.addEventListener('click', (e) => {
        e.stopPropagation();
        if (splashMap.classList.contains('zoomed')) {
          splashMap.classList.remove('zoomed');
          mapOverlay.classList.remove('visible');
        } else {
          splashMap.classList.add('zoomed');
          mapOverlay.classList.add('visible');
        }
      });
      
      mapOverlay.addEventListener('click', () => {
        splashMap.classList.remove('zoomed');
        mapOverlay.classList.remove('visible');
      });
    }

    function handleAction() {
      if (gameState.nearNPC) {
        openDialog(gameState.nearNPC);
      } else if (gameState.nearWanderer) {
        openWandererDialog(gameState.nearWanderer);
      }
    }

    function openDialog(locationId) {
      const dialog = DIALOGS[locationId];
      if (!dialog) return;

      // üéµ PLAY VOICE!
      playVoice(locationId);

      gameState.dialogOpen = true;
      
      // Check if first visit
      const isNewVisit = !gameState.visited.has(locationId);
      if (isNewVisit) {
        gameState.visited.add(locationId);
        updateStars();
      }

      // Update dialog UI
      document.getElementById('dialog-avatar').textContent = dialog.avatar;
      document.getElementById('dialog-name').textContent = dialog.name;
      document.getElementById('dialog-role').textContent = dialog.role;
      document.getElementById('dialog-content').innerHTML = dialog.content;
      document.getElementById('dialog-overlay').classList.add('visible');
      document.getElementById('action-btn').classList.remove('visible');

      // Store for notification on close
      if (isNewVisit) {
        gameState.pendingNotification = locationId;
      }
    }

    function openWandererDialog(npc) {
      const data = npc.userData;
      const quote = data.quotes[Math.floor(Math.random() * data.quotes.length)];

      // üéµ PLAY RANDOM VOICE!
      playRandomWandererVoice();

      gameState.dialogOpen = true;

      document.getElementById('dialog-avatar').textContent = 'ü§™';
      document.getElementById('dialog-name').textContent = data.name;
      document.getElementById('dialog-role').textContent = data.role;
      document.getElementById('dialog-content').innerHTML = `
        <div class="funny-quote" style="margin-top: 0;">${quote}</div>
        <p style="text-align: center; color: var(--text-light); font-size: 0.9rem; margin-top: 1rem;">*${data.name} wanders off humming*</p>
      `;
      document.getElementById('dialog-overlay').classList.add('visible');
      document.getElementById('action-btn').classList.remove('visible');
    }

    function closeDialog() {
      gameState.dialogOpen = false;
      document.getElementById('dialog-overlay').classList.remove('visible');

      // Show mission notification if this was a new visit
      if (gameState.pendingNotification) {
        const locationId = gameState.pendingNotification;
        showMissionNotification(locationId);
        gameState.pendingNotification = null;

        // Trigger Bernie listeners if we just talked to Princess Bernie (speakers)
        if (locationId === 'speakers' && !gameState.bernieListenersActive) {
          gameState.bernieListenersActive = true;
          // Set listeners to gathering state
          bernieListeners.forEach(listener => {
            listener.userData.state = 'gathering';
          });
          
          // After 8 seconds, they get hungry and leave for cake
          setTimeout(() => {
            gameState.bernieListenersLeaving = true;
            bernieListeners.forEach(listener => {
              listener.userData.state = 'leaving';
              // Show hungry message
              showListenerHungryMessage(listener);
            });
          }, 8000);
        }

        // Check if all missions complete - show completion after a delay
        if (gameState.visited.size === 5 && !gameState.completionShown) {
          setTimeout(() => {
            gameState.completionShown = true;
            document.getElementById('completion-modal').classList.add('visible');
          }, 1500);
        }
      }
    }

    function showListenerHungryMessage(listener) {
      const vec = listener.position.clone().project(camera);
      if (vec.z > 1) return;

      const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-vec.y * 0.5 + 0.5) * window.innerHeight;

      const messages = [
        "I smell CAKE! üç∞",
        "Did someone say dessert?",
        "My tummy is rumbling!",
        "Time for snacks!",
        "Cake break! üßÅ"
      ];
      
      const msg = document.createElement('div');
      msg.className = 'floating-message';
      msg.textContent = messages[Math.floor(Math.random() * messages.length)];
      msg.style.left = x + 'px';
      msg.style.top = (y - 80) + 'px';
      document.body.appendChild(msg);
      setTimeout(() => msg.remove(), 3000);

      // üéµ Occasionally play voice (15% chance)
      if (Math.random() < 0.15) {
        const now = Date.now();
        if (now - (listener.userData.lastVoice || 0) > WANDERER_VOICE_COOLDOWN) {
          listener.userData.lastVoice = now;
          playRandomWandererVoice();
        }
      }
    }

    function closeCompletion() {
      document.getElementById('completion-modal').classList.remove('visible');
    }

    function updateStars() {
      const locationIds = ['palace', 'teashop', 'speakers', 'guests', 'feast'];
      locationIds.forEach((id, index) => {
        if (gameState.visited.has(id)) {
          document.getElementById(`star-${index}`).classList.add('collected');
          document.querySelector(`.map-icon[data-location="${id}"]`).classList.add('visited');
        }
      });
    }

    function showMissionNotification(locationId) {
      const loc = LOCATIONS.find(l => l.id === locationId);
      const name = loc ? loc.name : locationId;

      const notif = document.createElement('div');
      notif.className = 'mission-notif';
      notif.innerHTML = `<span class="mission-notif-icon">‚≠ê</span>${name} completed!`;
      document.body.appendChild(notif);
      setTimeout(() => notif.remove(), 3000);
    }

    function showCollectPopup() {
      const messages = ['Yummy! üç¨', 'Sweet! üç≠', 'Royal! üëë', 'Shiny! ‚ú®', 'Lovely! üíñ', 'Fabulous! üíé'];
      const popup = document.createElement('div');
      popup.className = 'collect-popup';
      popup.textContent = messages[Math.floor(Math.random() * messages.length)];
      document.body.appendChild(popup);
      setTimeout(() => popup.remove(), 1000);
    }

    function showSweetIntro() {
      const sweetIntro = document.getElementById('sweet-intro');
      if (!sweetIntro) return;
      sweetIntro.classList.add('visible');
    }

    function dismissSweetIntro() {
      const sweetIntro = document.getElementById('sweet-intro');
      if (!sweetIntro) return;
      sweetIntro.classList.remove('visible');
      gameState.timeScale = 1;
      gameState.dialogOpen = false;
    }

    function showFloatingMessage(npc) {
      const now = Date.now();
      // 7 second base cooldown + random 0-4 seconds to prevent all talking at once
      const cooldown = 7000 + (npc.userData.chatOffset || 0);
      if (now - npc.userData.lastQuote < cooldown) return;
      npc.userData.lastQuote = now;
      npc.userData.chatOffset = Math.random() * 4000; // Randomize next cooldown

      const vec = npc.position.clone().project(camera);
      if (vec.z > 1) return; // Behind camera
      
      // Only show if reasonably on screen
      if (vec.x < -0.8 || vec.x > 0.8 || vec.y < -0.8 || vec.y > 0.8) return;

      const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
      const y = (-vec.y * 0.5 + 0.5) * window.innerHeight;

      // Use NPC's own quotes
      const quotes = npc.userData.quotes || ["La la la~ üéµ", "Nice day!", "*hums*"];
      
      const msg = document.createElement('div');
      msg.className = 'floating-message';
      msg.textContent = quotes[Math.floor(Math.random() * quotes.length)];
      msg.style.left = x + 'px';
      msg.style.top = (y - 80) + 'px';
      document.body.appendChild(msg);
      setTimeout(() => msg.remove(), 3000);
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta() * gameState.timeScale;
      const time = clock.getElapsedTime();
      const now = performance.now();

      if (gameState.started && !gameState.dialogOpen) {
        // Player movement
        const combinedInputX = Math.max(-1, Math.min(1, joystickInput.x + (desktopModeEnabled ? keyboardInput.x : 0)));
        const combinedInputY = Math.max(-1, Math.min(1, joystickInput.y + (desktopModeEnabled ? keyboardInput.y : 0)));
        const isMoving = combinedInputX !== 0 || combinedInputY !== 0;
        
        if (isMoving) {
          const playerSpeed = getPlayerSpeed(now);
          const moveX = combinedInputX * playerSpeed * delta;
          const moveZ = combinedInputY * playerSpeed * delta;
          const newX = player.position.x + moveX;
          const newZ = player.position.z + moveZ;

          if (!checkCollision(newX, player.position.z)) {
            player.position.x = newX;
          }
          if (!checkCollision(player.position.x, newZ)) {
            player.position.z = newZ;
          }

          // Face movement direction
          const angle = Math.atan2(combinedInputX, combinedInputY);
          player.rotation.y = THREE.MathUtils.lerp(player.rotation.y, angle, 0.15);

          // Waddle animation
          player.rotation.z = Math.sin(time * 15) * 0.12;
          player.position.y = player.userData.baseY + Math.abs(Math.sin(time * 18)) * 0.12;
        } else {
          // Idle animation
          player.rotation.z = THREE.MathUtils.lerp(player.rotation.z, 0, 0.1);
          player.position.y = player.userData.baseY + Math.sin(time * 2) * 0.03;
        }

        // Camera follow with gentle momentum zoom
        if (isMoving !== cameraZoomState.moving) {
          cameraZoomState.moving = isMoving;
          cameraZoomState.lastMoveChange = time;
        }

        if (cameraZoomState.moving) {
          if (time - cameraZoomState.lastMoveChange > cameraZoomState.zoomOutDelay) {
            cameraZoomState.targetOffset = cameraZoomState.zoomedOutOffset;
          }
        } else if (time - cameraZoomState.lastMoveChange > cameraZoomState.zoomInDelay) {
          cameraZoomState.targetOffset = cameraZoomState.baseOffset;
        }

        cameraZoomState.currentOffset = THREE.MathUtils.lerp(
          cameraZoomState.currentOffset,
          cameraZoomState.targetOffset,
          0.04
        );

        cameraTarget.set(player.position.x, player.position.y + 1, player.position.z);
        const idealPos = new THREE.Vector3(
          player.position.x,
          player.position.y + cameraZoomState.currentOffset,
          player.position.z + cameraZoomState.currentOffset
        );
        camera.position.lerp(idealPos, 0.08);
        camera.lookAt(cameraTarget);

        // Check NPC proximity
        let nearestNPC = null;
        let nearestWanderer = null;
        let nearestDist = Infinity;

        Object.entries(npcs).forEach(([id, npc]) => {
          const dist = player.position.distanceTo(npc.position);
          if (dist < 3.5 && dist < nearestDist) {
            nearestDist = dist;
            nearestNPC = id;
            nearestWanderer = null;
          }
        });

        wanderers.forEach(npc => {
          const dist = player.position.distanceTo(npc.position);
          if (dist < 3.5 && dist < nearestDist) {
            nearestDist = dist;
            nearestNPC = null;
            nearestWanderer = npc;
          }
        });

        gameState.nearNPC = nearestNPC;
        gameState.nearWanderer = nearestWanderer;

        const actionBtn = document.getElementById('action-btn');
        if (nearestNPC || nearestWanderer) {
          actionBtn.classList.add('visible');
          if (nearestNPC) {
            const icon = gameState.visited.has(nearestNPC) ? 'üí¨' : '‚ùì';
            actionBtn.innerHTML = `<span>${icon}</span><span>Tap to Chat</span>`;
          } else {
            actionBtn.innerHTML = `<span>ü§™</span><span>Say Hi!</span>`;
          }
        } else {
          actionBtn.classList.remove('visible');
        }

        // Check collectibles
        collectibles.forEach(col => {
          if (col.userData.collected) return;
          if (player.position.distanceTo(col.position) < 1.2) {
            col.userData.collected = true;
            col.visible = false;
            gameState.collected++;
            document.getElementById('collectible-count').textContent = gameState.collected;
            showCollectPopup();
            spawnCelebrationBurst();
            player.userData.boostEndTime = now + BOOST_DURATION;
            if (!gameState.firstSweetShown) {
              gameState.firstSweetShown = true;
              gameState.timeScale = 0.2;
              gameState.dialogOpen = true;
              showSweetIntro();
            }
          }
        });

        // Update current location display
        let nearestBuilding = null;
        let nearestBuildingDist = Infinity;
        Object.entries(buildings).forEach(([id, building]) => {
          const dist = player.position.distanceTo(building.position);
          if (dist < nearestBuildingDist) {
            nearestBuildingDist = dist;
            nearestBuilding = building;
          }
        });

        if (nearestBuilding && nearestBuilding.userData.id !== gameState.currentLocation) {
          gameState.currentLocation = nearestBuilding.userData.id;
          document.getElementById('location-icon').textContent = nearestBuilding.userData.icon;
          document.getElementById('location-name').textContent = nearestBuilding.userData.name;
          document.querySelectorAll('.map-icon').forEach(icon => {
            icon.classList.toggle('current', icon.dataset.location === gameState.currentLocation);
          });
        }

        // Update wandering NPCs
        wanderers.forEach(npc => {
          npc.userData.timer -= delta;
          if (npc.userData.timer <= 0) {
            npc.userData.walkAngle += (Math.random() - 0.5) * Math.PI;
            // Fast runners change direction more often
            npc.userData.timer = npc.userData.speed === 'fast' 
              ? 0.5 + Math.random() * 1 
              : 2 + Math.random() * 4;
          }
          
          // Always try to show message - the function handles the 3s cooldown
          showFloatingMessage(npc);
          maybePlayAmbientVoice(npc);

          const speed = npc.userData.walkSpeed * delta;
          const newX = npc.position.x + Math.sin(npc.userData.walkAngle) * speed;
          const newZ = npc.position.z + Math.cos(npc.userData.walkAngle) * speed;

          if (!checkCollision(newX, newZ)) {
            npc.position.x = newX;
            npc.position.z = newZ;
          } else {
            npc.userData.walkAngle += Math.PI * 0.5;
          }

          npc.rotation.y = npc.userData.walkAngle;
          
          // Different animation speeds based on NPC type
          if (npc.userData.speed === 'fast') {
            // Fast runners - very bouncy and wobbly
            npc.rotation.z = Math.sin(time * 25) * 0.2;
            npc.position.y = Math.abs(Math.sin(time * 30)) * 0.2;
          } else if (npc.userData.speed === 'slow') {
            // Elderly - slow shuffle
            npc.rotation.z = Math.sin(time * 4) * 0.03;
            npc.position.y = Math.abs(Math.sin(time * 5)) * 0.02;
          } else {
            // Normal
            npc.rotation.z = Math.sin(time * 12) * 0.08;
            npc.position.y = Math.abs(Math.sin(time * 15)) * 0.08;
          }
        });
      }

      // Ambient animations (always run)
      updateCelebrationParticles(delta);
      clouds.forEach(cloud => {
        cloud.position.x += cloud.userData.speed;
        if (cloud.position.x > 60) cloud.position.x = -60;
      });

      // Animate bees
      bees.forEach(bee => {
        const data = bee.userData;
        // Circular flight around palace
        data.angle += data.speed * delta;
        bee.position.x = data.palaceX + Math.cos(data.angle) * data.radius;
        bee.position.z = data.palaceZ + Math.sin(data.angle) * data.radius;
        // Bobbing up and down
        bee.position.y = data.baseY + Math.sin(time * data.bobSpeed) * 0.5;
        // Face direction of movement
        bee.rotation.y = data.angle + Math.PI / 2;
        // Wing flutter
        bee.children.forEach((child, i) => {
          if (i >= 3) { // Wings are children 3 and 4
            child.rotation.x = Math.sin(time * 30) * 0.3;
          }
        });
      });

      // Animate corgis
      corgis.forEach(corgi => {
        const data = corgi.userData;
        const bob = Math.sin(time * 2 + data.bobOffset) * 0.08;
        corgi.position.y = data.baseY + bob;
        data.legs.forEach(leg => {
          leg.rotation.x = Math.sin(time * 6 + data.bobOffset) * 0.6 * leg.userData.swingDir;
        });
      });

      // Animate Bernie listeners
      const feastPos = LOCATIONS.find(l => l.id === 'feast');
      bernieListeners.forEach(listener => {
        const data = listener.userData;
        const speed = data.speed * delta;
        
        // Show floating messages (especially when listening!)
        if (data.state === 'listening') {
          showFloatingMessage(listener);
        } else if (Math.random() < 0.01) { // Less frequent when not listening
          showFloatingMessage(listener);
        }
        maybePlayAmbientVoice(listener);
        
        if (data.state === 'gathering') {
          // Move towards target position around Bernie
          const dx = data.targetX - listener.position.x;
          const dz = data.targetZ - listener.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          
          if (dist > 0.5) {
            listener.position.x += (dx / dist) * speed * 2;
            listener.position.z += (dz / dist) * speed * 2;
            listener.rotation.y = Math.atan2(dx, dz);
            // Walk animation
            listener.rotation.z = Math.sin(time * 12) * 0.08;
            listener.position.y = Math.abs(Math.sin(time * 15)) * 0.08;
          } else {
            data.state = 'listening';
          }
        } else if (data.state === 'listening') {
          // Face Bernie (speakers NPC) and nod occasionally
          const speakersPos = LOCATIONS.find(l => l.id === 'speakers');
          const npcPos = npcs['speakers'].position;
          listener.rotation.y = Math.atan2(
            npcPos.x - listener.position.x,
            npcPos.z - listener.position.z
          );
          // Nodding animation
          listener.rotation.x = Math.sin(time * 2) * 0.1;
          listener.position.y = 0;
        } else if (data.state === 'leaving') {
          // Head towards feast hall for cake!
          const dx = feastPos.x - listener.position.x;
          const dz = feastPos.z - listener.position.z;
          const dist = Math.sqrt(dx * dx + dz * dz);
          
          // Show hungry messages
          if (Math.random() < 0.015) {
            const hungryQuotes = ["CAKE TIME! üç∞", "My tummy is calling!", "Dessert awaits!", "I smell frosting!", "Can't talk, eating soon!"];
            const now = Date.now();
            if (now - data.lastQuote > 2000) {
              data.lastQuote = now;
              const vec = listener.position.clone().project(camera);
              if (vec.z < 1 && vec.x > -0.8 && vec.x < 0.8) {
                const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vec.y * 0.5 + 0.5) * window.innerHeight;
                const msg = document.createElement('div');
                msg.className = 'floating-message';
                msg.textContent = hungryQuotes[Math.floor(Math.random() * hungryQuotes.length)];
                msg.style.left = x + 'px';
                msg.style.top = (y - 80) + 'px';
                document.body.appendChild(msg);
                setTimeout(() => msg.remove(), 3000);
              }
            }
          }
          
          if (dist > 3) {
            listener.position.x += (dx / dist) * speed * 2.5;
            listener.position.z += (dz / dist) * speed * 2.5;
            listener.rotation.y = Math.atan2(dx, dz);
            // Excited walking animation
            listener.rotation.z = Math.sin(time * 15) * 0.12;
            listener.position.y = Math.abs(Math.sin(time * 18)) * 0.12;
          } else {
            // Arrived at feast hall, start wandering there
            data.state = 'arrived';
          }
        } else if (data.state === 'arrived') {
          // Wander around feast hall happily
          data.wanderAngle += (Math.random() - 0.5) * 0.1;
          const newX = listener.position.x + Math.sin(data.wanderAngle) * speed;
          const newZ = listener.position.z + Math.cos(data.wanderAngle) * speed;
          
          // Show happy eating messages
          if (Math.random() < 0.01) {
            const eatingQuotes = ["*nom nom nom*", "This cake is DIVINE! üç∞", "More frosting please!", "I regret nothing!", "Best. Day. Ever."];
            const now = Date.now();
            if (now - data.lastQuote > 3000) {
              data.lastQuote = now;
              const vec = listener.position.clone().project(camera);
              if (vec.z < 1 && vec.x > -0.8 && vec.x < 0.8) {
                const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vec.y * 0.5 + 0.5) * window.innerHeight;
                const msg = document.createElement('div');
                msg.className = 'floating-message';
                msg.textContent = eatingQuotes[Math.floor(Math.random() * eatingQuotes.length)];
                msg.style.left = x + 'px';
                msg.style.top = (y - 80) + 'px';
                document.body.appendChild(msg);
                setTimeout(() => msg.remove(), 3000);
              }
            }
          }
          
          // Stay near feast hall
          const distToFeast = Math.sqrt(
            Math.pow(newX - feastPos.x, 2) + Math.pow(newZ - feastPos.z, 2)
          );
          if (distToFeast < 8 && !checkCollision(newX, newZ)) {
            listener.position.x = newX;
            listener.position.z = newZ;
          } else {
            data.wanderAngle += Math.PI;
          }
          listener.rotation.y = data.wanderAngle;
          listener.rotation.z = Math.sin(time * 10) * 0.06;
          listener.position.y = Math.abs(Math.sin(time * 12)) * 0.06;
        } else {
          // Default wandering state
          data.wanderAngle += (Math.random() - 0.5) * 0.05;
          const newX = listener.position.x + Math.sin(data.wanderAngle) * speed * 0.5;
          const newZ = listener.position.z + Math.cos(data.wanderAngle) * speed * 0.5;
          
          if (!checkCollision(newX, newZ)) {
            listener.position.x = newX;
            listener.position.z = newZ;
          } else {
            data.wanderAngle += Math.PI * 0.5;
          }
          listener.rotation.y = data.wanderAngle;
          listener.rotation.z = Math.sin(time * 8) * 0.05;
          listener.position.y = Math.abs(Math.sin(time * 10)) * 0.05;
        }
      });

      // NPC indicator float
      Object.values(npcs).forEach(npc => {
        npc.children.forEach(child => {
          if (child.userData.isIndicator) {
            child.position.y = 2.5 + Math.sin(time * 3) * 0.15;
            child.rotation.y = time * 2;
          }
        });
      });

      // Collectible float and spin
      collectibles.forEach(col => {
        if (!col.userData.collected) {
          col.position.y = 0.5 + Math.sin(time * 3 + col.userData.floatOffset) * 0.15;
          col.rotation.y = time * 1.5;
        }
      });

      // Building pulse when near
      Object.values(buildings).forEach(building => {
        const dist = player.position.distanceTo(building.position);
        if (dist < 6) {
          building.scale.setScalar(1 + Math.sin(time * 5) * 0.02);
        } else {
          building.scale.setScalar(THREE.MathUtils.lerp(building.scale.x, 1, 0.1));
        }
      });

      renderer.render(scene, camera);
    }

    // Start the game
    init();
  </script>
  <script>
  window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
</script>
<script defer src="/_vercel/insights/script.js"></script>
</body>
</html>
